#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Nov  9 18:31:45 2011 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class eagle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, compatibility=None, drawing=None):
        self.version = _cast(None, version)
        self.compatibility = compatibility
        self.drawing = drawing
    def factory(*args_, **kwargs_):
        if eagle.subclass:
            return eagle.subclass(*args_, **kwargs_)
        else:
            return eagle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_compatibility(self): return self.compatibility
    def set_compatibility(self, compatibility): self.compatibility = compatibility
    def get_drawing(self): return self.drawing
    def set_drawing(self, drawing): self.drawing = drawing
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='t:', name_='eagle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eagle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='eagle'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='eagle', fromsubclass_=False):
        if self.compatibility is not None:
            self.compatibility.export(outfile, level, namespace_, name_='compatibility')
        if self.drawing is not None:
            self.drawing.export(outfile, level, namespace_, name_='drawing', )
    def hasContent_(self):
        if (
            self.compatibility is not None or
            self.drawing is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='eagle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.compatibility is not None:
            showIndent(outfile, level)
            outfile.write('compatibility=model_.compatibility(\n')
            self.compatibility.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.drawing is not None:
            showIndent(outfile, level)
            outfile.write('drawing=model_.drawing(\n')
            self.drawing.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'compatibility':
            obj_ = compatibility.factory()
            obj_.build(child_)
            self.set_compatibility(obj_)
        elif nodeName_ == 'drawing':
            obj_ = drawing.factory()
            obj_.build(child_)
            self.set_drawing(obj_)
# end class eagle


class compatibility(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        self.note = note
    def factory(*args_, **kwargs_):
        if compatibility.subclass:
            return compatibility.subclass(*args_, **kwargs_)
        else:
            return compatibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def export(self, outfile, level, namespace_='t:', name_='compatibility', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compatibility')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='compatibility'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='compatibility', fromsubclass_=False):
        if self.note is not None:
            self.note.export(outfile, level, namespace_, name_='note', )
    def hasContent_(self):
        if (
            self.note is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='compatibility'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('note=model_.note(\n')
            self.note.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            obj_ = note.factory()
            obj_.build(child_)
            self.set_note(obj_)
# end class compatibility


class note(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, severity=None, valueOf_=None, mixedclass_=None, content_=None):
        self.version = _cast(None, version)
        self.severity = _cast(None, severity)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if note.subclass:
            return note.subclass(*args_, **kwargs_)
        else:
            return note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='note', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='note')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='note'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' % (self.gds_format_string(quote_attrib(self.severity).encode(ExternalEncoding), input_name='severity'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='note', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='note'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = "%s",\n' % (self.severity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class note


class drawing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, settings=None, grid=None, layers=None, library=None, schematic=None, board=None):
        self.settings = settings
        self.grid = grid
        self.layers = layers
        self.library = library
        self.schematic = schematic
        self.board = board
    def factory(*args_, **kwargs_):
        if drawing.subclass:
            return drawing.subclass(*args_, **kwargs_)
        else:
            return drawing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_settings(self): return self.settings
    def set_settings(self, settings): self.settings = settings
    def get_grid(self): return self.grid
    def set_grid(self, grid): self.grid = grid
    def get_layers(self): return self.layers
    def set_layers(self, layers): self.layers = layers
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_schematic(self): return self.schematic
    def set_schematic(self, schematic): self.schematic = schematic
    def get_board(self): return self.board
    def set_board(self, board): self.board = board
    def export(self, outfile, level, namespace_='t:', name_='drawing', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drawing')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='drawing'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='drawing', fromsubclass_=False):
        if self.settings is not None:
            self.settings.export(outfile, level, namespace_, name_='settings')
        if self.grid is not None:
            self.grid.export(outfile, level, namespace_, name_='grid')
        if self.layers is not None:
            self.layers.export(outfile, level, namespace_, name_='layers', )
        if self.library is not None:
            self.library.export(outfile, level, namespace_, name_='library', )
        if self.schematic is not None:
            self.schematic.export(outfile, level, namespace_, name_='schematic', )
        if self.board is not None:
            self.board.export(outfile, level, namespace_, name_='board', )
    def hasContent_(self):
        if (
            self.settings is not None or
            self.grid is not None or
            self.layers is not None or
            self.library is not None or
            self.schematic is not None or
            self.board is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='drawing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.settings is not None:
            showIndent(outfile, level)
            outfile.write('settings=model_.settings(\n')
            self.settings.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.grid is not None:
            showIndent(outfile, level)
            outfile.write('grid=model_.grid(\n')
            self.grid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.layers is not None:
            showIndent(outfile, level)
            outfile.write('layers=model_.layers(\n')
            self.layers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.library is not None:
            showIndent(outfile, level)
            outfile.write('library=model_.library(\n')
            self.library.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.schematic is not None:
            showIndent(outfile, level)
            outfile.write('schematic=model_.schematic(\n')
            self.schematic.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.board is not None:
            showIndent(outfile, level)
            outfile.write('board=model_.board(\n')
            self.board.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'settings':
            obj_ = settings.factory()
            obj_.build(child_)
            self.set_settings(obj_)
        elif nodeName_ == 'grid':
            obj_ = grid.factory()
            obj_.build(child_)
            self.set_grid(obj_)
        elif nodeName_ == 'layers':
            obj_ = layers.factory()
            obj_.build(child_)
            self.set_layers(obj_)
        elif nodeName_ == 'library':
            obj_ = library.factory()
            obj_.build(child_)
            self.set_library(obj_)
        elif nodeName_ == 'schematic':
            obj_ = schematic.factory()
            obj_.build(child_)
            self.set_schematic(obj_)
        elif nodeName_ == 'board':
            obj_ = board.factory()
            obj_.build(child_)
            self.set_board(obj_)
# end class drawing


class library(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, packages=None, symbols=None, devicesets=None):
        self.name = _cast(None, name)
        self.description = description
        self.packages = packages
        self.symbols = symbols
        self.devicesets = devicesets
    def factory(*args_, **kwargs_):
        if library.subclass:
            return library.subclass(*args_, **kwargs_)
        else:
            return library(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_packages(self): return self.packages
    def set_packages(self, packages): self.packages = packages
    def get_symbols(self): return self.symbols
    def set_symbols(self, symbols): self.symbols = symbols
    def get_devicesets(self): return self.devicesets
    def set_devicesets(self, devicesets): self.devicesets = devicesets
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='library', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='library')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='library'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='library', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.packages is not None:
            self.packages.export(outfile, level, namespace_, name_='packages')
        if self.symbols is not None:
            self.symbols.export(outfile, level, namespace_, name_='symbols')
        if self.devicesets is not None:
            self.devicesets.export(outfile, level, namespace_, name_='devicesets')
    def hasContent_(self):
        if (
            self.description is not None or
            self.packages is not None or
            self.symbols is not None or
            self.devicesets is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='library'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.packages is not None:
            showIndent(outfile, level)
            outfile.write('packages=model_.packages(\n')
            self.packages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.symbols is not None:
            showIndent(outfile, level)
            outfile.write('symbols=model_.symbols(\n')
            self.symbols.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devicesets is not None:
            showIndent(outfile, level)
            outfile.write('devicesets=model_.devicesets(\n')
            self.devicesets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'packages':
            obj_ = packages.factory()
            obj_.build(child_)
            self.set_packages(obj_)
        elif nodeName_ == 'symbols':
            obj_ = symbols.factory()
            obj_.build(child_)
            self.set_symbols(obj_)
        elif nodeName_ == 'devicesets':
            obj_ = devicesets.factory()
            obj_.build(child_)
            self.set_devicesets(obj_)
# end class library


class schematic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xrefpart=None, xreflabel=None, description=None, libraries=None, attributes=None, variantdefs=None, classes=None, parts=None, sheets=None, errors=None):
        self.xrefpart = _cast(None, xrefpart)
        self.xreflabel = _cast(None, xreflabel)
        self.description = description
        self.libraries = libraries
        self.attributes = attributes
        self.variantdefs = variantdefs
        self.classes = classes
        self.parts = parts
        self.sheets = sheets
        self.errors = errors
    def factory(*args_, **kwargs_):
        if schematic.subclass:
            return schematic.subclass(*args_, **kwargs_)
        else:
            return schematic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_libraries(self): return self.libraries
    def set_libraries(self, libraries): self.libraries = libraries
    def get_attributes(self): return self.attributes
    def set_attributes(self, attributes): self.attributes = attributes
    def get_variantdefs(self): return self.variantdefs
    def set_variantdefs(self, variantdefs): self.variantdefs = variantdefs
    def get_classes(self): return self.classes
    def set_classes(self, classes): self.classes = classes
    def get_parts(self): return self.parts
    def set_parts(self, parts): self.parts = parts
    def get_sheets(self): return self.sheets
    def set_sheets(self, sheets): self.sheets = sheets
    def get_errors(self): return self.errors
    def set_errors(self, errors): self.errors = errors
    def get_xrefpart(self): return self.xrefpart
    def set_xrefpart(self, xrefpart): self.xrefpart = xrefpart
    def get_xreflabel(self): return self.xreflabel
    def set_xreflabel(self, xreflabel): self.xreflabel = xreflabel
    def export(self, outfile, level, namespace_='t:', name_='schematic', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='schematic')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='schematic'):
        if self.xrefpart is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            outfile.write(' xrefpart=%s' % (self.gds_format_string(quote_attrib(self.xrefpart).encode(ExternalEncoding), input_name='xrefpart'), ))
        if self.xreflabel is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            outfile.write(' xreflabel=%s' % (self.gds_format_string(quote_attrib(self.xreflabel).encode(ExternalEncoding), input_name='xreflabel'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='schematic', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.libraries is not None:
            self.libraries.export(outfile, level, namespace_, name_='libraries')
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespace_, name_='attributes')
        if self.variantdefs is not None:
            self.variantdefs.export(outfile, level, namespace_, name_='variantdefs')
        if self.classes is not None:
            self.classes.export(outfile, level, namespace_, name_='classes')
        if self.parts is not None:
            self.parts.export(outfile, level, namespace_, name_='parts')
        if self.sheets is not None:
            self.sheets.export(outfile, level, namespace_, name_='sheets')
        if self.errors is not None:
            self.errors.export(outfile, level, namespace_, name_='errors')
    def hasContent_(self):
        if (
            self.description is not None or
            self.libraries is not None or
            self.attributes is not None or
            self.variantdefs is not None or
            self.classes is not None or
            self.parts is not None or
            self.sheets is not None or
            self.errors is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='schematic'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.xrefpart is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            showIndent(outfile, level)
            outfile.write('xrefpart = "%s",\n' % (self.xrefpart,))
        if self.xreflabel is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            showIndent(outfile, level)
            outfile.write('xreflabel = "%s",\n' % (self.xreflabel,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.libraries is not None:
            showIndent(outfile, level)
            outfile.write('libraries=model_.libraries(\n')
            self.libraries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributes is not None:
            showIndent(outfile, level)
            outfile.write('attributes=model_.attributes(\n')
            self.attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variantdefs is not None:
            showIndent(outfile, level)
            outfile.write('variantdefs=model_.variantdefs(\n')
            self.variantdefs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.classes is not None:
            showIndent(outfile, level)
            outfile.write('classes=model_.classes(\n')
            self.classes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parts is not None:
            showIndent(outfile, level)
            outfile.write('parts=model_.parts(\n')
            self.parts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sheets is not None:
            showIndent(outfile, level)
            outfile.write('sheets=model_.sheets(\n')
            self.sheets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errors is not None:
            showIndent(outfile, level)
            outfile.write('errors=model_.errors(\n')
            self.errors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xrefpart', node)
        if value is not None and 'xrefpart' not in already_processed:
            already_processed.append('xrefpart')
            self.xrefpart = value
        value = find_attr_value_('xreflabel', node)
        if value is not None and 'xreflabel' not in already_processed:
            already_processed.append('xreflabel')
            self.xreflabel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'libraries':
            obj_ = libraries.factory()
            obj_.build(child_)
            self.set_libraries(obj_)
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory()
            obj_.build(child_)
            self.set_attributes(obj_)
        elif nodeName_ == 'variantdefs':
            obj_ = variantdefs.factory()
            obj_.build(child_)
            self.set_variantdefs(obj_)
        elif nodeName_ == 'classes':
            obj_ = classes.factory()
            obj_.build(child_)
            self.set_classes(obj_)
        elif nodeName_ == 'parts':
            obj_ = parts.factory()
            obj_.build(child_)
            self.set_parts(obj_)
        elif nodeName_ == 'sheets':
            obj_ = sheets.factory()
            obj_.build(child_)
            self.set_sheets(obj_)
        elif nodeName_ == 'errors':
            obj_ = errors.factory()
            obj_.build(child_)
            self.set_errors(obj_)
# end class schematic


class board(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, plain=None, libraries=None, attributes=None, variantdefs=None, classes=None, designrules=None, autorouter=None, elements=None, signals=None, errors=None):
        self.description = description
        self.plain = plain
        self.libraries = libraries
        self.attributes = attributes
        self.variantdefs = variantdefs
        self.classes = classes
        self.designrules = designrules
        self.autorouter = autorouter
        self.elements = elements
        self.signals = signals
        self.errors = errors
    def factory(*args_, **kwargs_):
        if board.subclass:
            return board.subclass(*args_, **kwargs_)
        else:
            return board(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_plain(self): return self.plain
    def set_plain(self, plain): self.plain = plain
    def get_libraries(self): return self.libraries
    def set_libraries(self, libraries): self.libraries = libraries
    def get_attributes(self): return self.attributes
    def set_attributes(self, attributes): self.attributes = attributes
    def get_variantdefs(self): return self.variantdefs
    def set_variantdefs(self, variantdefs): self.variantdefs = variantdefs
    def get_classes(self): return self.classes
    def set_classes(self, classes): self.classes = classes
    def get_designrules(self): return self.designrules
    def set_designrules(self, designrules): self.designrules = designrules
    def get_autorouter(self): return self.autorouter
    def set_autorouter(self, autorouter): self.autorouter = autorouter
    def get_elements(self): return self.elements
    def set_elements(self, elements): self.elements = elements
    def get_signals(self): return self.signals
    def set_signals(self, signals): self.signals = signals
    def get_errors(self): return self.errors
    def set_errors(self, errors): self.errors = errors
    def export(self, outfile, level, namespace_='t:', name_='board', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='board')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='board'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='board', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.plain is not None:
            self.plain.export(outfile, level, namespace_, name_='plain')
        if self.libraries is not None:
            self.libraries.export(outfile, level, namespace_, name_='libraries')
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespace_, name_='attributes')
        if self.variantdefs is not None:
            self.variantdefs.export(outfile, level, namespace_, name_='variantdefs')
        if self.classes is not None:
            self.classes.export(outfile, level, namespace_, name_='classes')
        if self.designrules is not None:
            self.designrules.export(outfile, level, namespace_, name_='designrules')
        if self.autorouter is not None:
            self.autorouter.export(outfile, level, namespace_, name_='autorouter')
        if self.elements is not None:
            self.elements.export(outfile, level, namespace_, name_='elements')
        if self.signals is not None:
            self.signals.export(outfile, level, namespace_, name_='signals')
        if self.errors is not None:
            self.errors.export(outfile, level, namespace_, name_='errors')
    def hasContent_(self):
        if (
            self.description is not None or
            self.plain is not None or
            self.libraries is not None or
            self.attributes is not None or
            self.variantdefs is not None or
            self.classes is not None or
            self.designrules is not None or
            self.autorouter is not None or
            self.elements is not None or
            self.signals is not None or
            self.errors is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='board'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plain is not None:
            showIndent(outfile, level)
            outfile.write('plain=model_.plain(\n')
            self.plain.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.libraries is not None:
            showIndent(outfile, level)
            outfile.write('libraries=model_.libraries(\n')
            self.libraries.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributes is not None:
            showIndent(outfile, level)
            outfile.write('attributes=model_.attributes(\n')
            self.attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variantdefs is not None:
            showIndent(outfile, level)
            outfile.write('variantdefs=model_.variantdefs(\n')
            self.variantdefs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.classes is not None:
            showIndent(outfile, level)
            outfile.write('classes=model_.classes(\n')
            self.classes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.designrules is not None:
            showIndent(outfile, level)
            outfile.write('designrules=model_.designrules(\n')
            self.designrules.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autorouter is not None:
            showIndent(outfile, level)
            outfile.write('autorouter=model_.autorouter(\n')
            self.autorouter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elements is not None:
            showIndent(outfile, level)
            outfile.write('elements=model_.elements(\n')
            self.elements.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.signals is not None:
            showIndent(outfile, level)
            outfile.write('signals=model_.signals(\n')
            self.signals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.errors is not None:
            showIndent(outfile, level)
            outfile.write('errors=model_.errors(\n')
            self.errors.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'plain':
            obj_ = plain.factory()
            obj_.build(child_)
            self.set_plain(obj_)
        elif nodeName_ == 'libraries':
            obj_ = libraries.factory()
            obj_.build(child_)
            self.set_libraries(obj_)
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory()
            obj_.build(child_)
            self.set_attributes(obj_)
        elif nodeName_ == 'variantdefs':
            obj_ = variantdefs.factory()
            obj_.build(child_)
            self.set_variantdefs(obj_)
        elif nodeName_ == 'classes':
            obj_ = classes.factory()
            obj_.build(child_)
            self.set_classes(obj_)
        elif nodeName_ == 'designrules':
            obj_ = designrules.factory()
            obj_.build(child_)
            self.set_designrules(obj_)
        elif nodeName_ == 'autorouter':
            obj_ = autorouter.factory()
            obj_.build(child_)
            self.set_autorouter(obj_)
        elif nodeName_ == 'elements':
            obj_ = elements.factory()
            obj_.build(child_)
            self.set_elements(obj_)
        elif nodeName_ == 'signals':
            obj_ = signals.factory()
            obj_.build(child_)
            self.set_signals(obj_)
        elif nodeName_ == 'errors':
            obj_ = errors.factory()
            obj_.build(child_)
            self.set_errors(obj_)
# end class board


class sheet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, plain=None, instances=None, busses=None, nets=None):
        self.description = description
        self.plain = plain
        self.instances = instances
        self.busses = busses
        self.nets = nets
    def factory(*args_, **kwargs_):
        if sheet.subclass:
            return sheet.subclass(*args_, **kwargs_)
        else:
            return sheet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_plain(self): return self.plain
    def set_plain(self, plain): self.plain = plain
    def get_instances(self): return self.instances
    def set_instances(self, instances): self.instances = instances
    def get_busses(self): return self.busses
    def set_busses(self, busses): self.busses = busses
    def get_nets(self): return self.nets
    def set_nets(self, nets): self.nets = nets
    def export(self, outfile, level, namespace_='t:', name_='sheet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sheet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='sheet'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='sheet', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.plain is not None:
            self.plain.export(outfile, level, namespace_, name_='plain')
        if self.instances is not None:
            self.instances.export(outfile, level, namespace_, name_='instances')
        if self.busses is not None:
            self.busses.export(outfile, level, namespace_, name_='busses')
        if self.nets is not None:
            self.nets.export(outfile, level, namespace_, name_='nets')
    def hasContent_(self):
        if (
            self.description is not None or
            self.plain is not None or
            self.instances is not None or
            self.busses is not None or
            self.nets is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sheet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plain is not None:
            showIndent(outfile, level)
            outfile.write('plain=model_.plain(\n')
            self.plain.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.instances is not None:
            showIndent(outfile, level)
            outfile.write('instances=model_.instances(\n')
            self.instances.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.busses is not None:
            showIndent(outfile, level)
            outfile.write('busses=model_.busses(\n')
            self.busses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nets is not None:
            showIndent(outfile, level)
            outfile.write('nets=model_.nets(\n')
            self.nets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'plain':
            obj_ = plain.factory()
            obj_.build(child_)
            self.set_plain(obj_)
        elif nodeName_ == 'instances':
            obj_ = instances.factory()
            obj_.build(child_)
            self.set_instances(obj_)
        elif nodeName_ == 'busses':
            obj_ = busses.factory()
            obj_.build(child_)
            self.set_busses(obj_)
        elif nodeName_ == 'nets':
            obj_ = nets.factory()
            obj_.build(child_)
            self.set_nets(obj_)
# end class sheet


class package(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, polygon=None, wire=None, text=None, circle=None, rectangle=None, frame=None, hole=None, pad=None, smd=None):
        self.name = _cast(None, name)
        self.description = description
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
        if hole is None:
            self.hole = []
        else:
            self.hole = hole
        if pad is None:
            self.pad = []
        else:
            self.pad = pad
        if smd is None:
            self.smd = []
        else:
            self.smd = smd
    def factory(*args_, **kwargs_):
        if package.subclass:
            return package.subclass(*args_, **kwargs_)
        else:
            return package(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_polygon(self): return self.polygon
    def set_polygon(self, polygon): self.polygon = polygon
    def add_polygon(self, value): self.polygon.append(value)
    def insert_polygon(self, index, value): self.polygon[index] = value
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def add_wire(self, value): self.wire.append(value)
    def insert_wire(self, index, value): self.wire[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text(self, index, value): self.text[index] = value
    def get_circle(self): return self.circle
    def set_circle(self, circle): self.circle = circle
    def add_circle(self, value): self.circle.append(value)
    def insert_circle(self, index, value): self.circle[index] = value
    def get_rectangle(self): return self.rectangle
    def set_rectangle(self, rectangle): self.rectangle = rectangle
    def add_rectangle(self, value): self.rectangle.append(value)
    def insert_rectangle(self, index, value): self.rectangle[index] = value
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def add_frame(self, value): self.frame.append(value)
    def insert_frame(self, index, value): self.frame[index] = value
    def get_hole(self): return self.hole
    def set_hole(self, hole): self.hole = hole
    def add_hole(self, value): self.hole.append(value)
    def insert_hole(self, index, value): self.hole[index] = value
    def get_pad(self): return self.pad
    def set_pad(self, pad): self.pad = pad
    def add_pad(self, value): self.pad.append(value)
    def insert_pad(self, index, value): self.pad[index] = value
    def get_smd(self): return self.smd
    def set_smd(self, smd): self.smd = smd
    def add_smd(self, value): self.smd.append(value)
    def insert_smd(self, index, value): self.smd[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='package', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='package')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='package'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='package', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
        for hole_ in self.hole:
            hole_.export(outfile, level, namespace_, name_='hole')
        for pad_ in self.pad:
            pad_.export(outfile, level, namespace_, name_='pad')
        for smd_ in self.smd:
            smd_.export(outfile, level, namespace_, name_='smd')
    def hasContent_(self):
        if (
            self.description is not None or
            self.polygon or
            self.wire or
            self.text or
            self.circle or
            self.rectangle or
            self.frame or
            self.hole or
            self.pad or
            self.smd
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='package'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hole=[\n')
        level += 1
        for hole_ in self.hole:
            showIndent(outfile, level)
            outfile.write('model_.hole(\n')
            hole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pad=[\n')
        level += 1
        for pad_ in self.pad:
            showIndent(outfile, level)
            outfile.write('model_.pad(\n')
            pad_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smd=[\n')
        level += 1
        for smd_ in self.smd:
            showIndent(outfile, level)
            outfile.write('model_.smd(\n')
            smd_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
        elif nodeName_ == 'hole':
            obj_ = hole.factory()
            obj_.build(child_)
            self.hole.append(obj_)
        elif nodeName_ == 'pad':
            obj_ = pad.factory()
            obj_.build(child_)
            self.pad.append(obj_)
        elif nodeName_ == 'smd':
            obj_ = smd.factory()
            obj_.build(child_)
            self.smd.append(obj_)
# end class package


class symbol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, polygon=None, wire=None, text=None, pin=None, circle=None, rectangle=None, frame=None):
        self.name = _cast(None, name)
        self.description = description
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if pin is None:
            self.pin = []
        else:
            self.pin = pin
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
    def factory(*args_, **kwargs_):
        if symbol.subclass:
            return symbol.subclass(*args_, **kwargs_)
        else:
            return symbol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_polygon(self): return self.polygon
    def set_polygon(self, polygon): self.polygon = polygon
    def add_polygon(self, value): self.polygon.append(value)
    def insert_polygon(self, index, value): self.polygon[index] = value
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def add_wire(self, value): self.wire.append(value)
    def insert_wire(self, index, value): self.wire[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text(self, index, value): self.text[index] = value
    def get_pin(self): return self.pin
    def set_pin(self, pin): self.pin = pin
    def add_pin(self, value): self.pin.append(value)
    def insert_pin(self, index, value): self.pin[index] = value
    def get_circle(self): return self.circle
    def set_circle(self, circle): self.circle = circle
    def add_circle(self, value): self.circle.append(value)
    def insert_circle(self, index, value): self.circle[index] = value
    def get_rectangle(self): return self.rectangle
    def set_rectangle(self, rectangle): self.rectangle = rectangle
    def add_rectangle(self, value): self.rectangle.append(value)
    def insert_rectangle(self, index, value): self.rectangle[index] = value
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def add_frame(self, value): self.frame.append(value)
    def insert_frame(self, index, value): self.frame[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='symbol', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='symbol')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='symbol'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='symbol', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for pin_ in self.pin:
            pin_.export(outfile, level, namespace_, name_='pin')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
    def hasContent_(self):
        if (
            self.description is not None or
            self.polygon or
            self.wire or
            self.text or
            self.pin or
            self.circle or
            self.rectangle or
            self.frame
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='symbol'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pin=[\n')
        level += 1
        for pin_ in self.pin:
            showIndent(outfile, level)
            outfile.write('model_.pin(\n')
            pin_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'pin':
            obj_ = pin.factory()
            obj_.build(child_)
            self.pin.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
# end class symbol


class deviceset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uservalue=None, prefix=None, name=None, description=None, gates=None, devices=None):
        self.uservalue = _cast(None, uservalue)
        self.prefix = _cast(None, prefix)
        self.name = _cast(None, name)
        self.description = description
        self.gates = gates
        self.devices = devices
    def factory(*args_, **kwargs_):
        if deviceset.subclass:
            return deviceset.subclass(*args_, **kwargs_)
        else:
            return deviceset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_gates(self): return self.gates
    def set_gates(self, gates): self.gates = gates
    def get_devices(self): return self.devices
    def set_devices(self, devices): self.devices = devices
    def get_uservalue(self): return self.uservalue
    def set_uservalue(self, uservalue): self.uservalue = uservalue
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='deviceset', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='deviceset')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='deviceset'):
        if self.uservalue is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            outfile.write(' uservalue=%s' % (self.gds_format_string(quote_attrib(self.uservalue).encode(ExternalEncoding), input_name='uservalue'), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            outfile.write(' prefix=%s' % (self.gds_format_string(quote_attrib(self.prefix).encode(ExternalEncoding), input_name='prefix'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='deviceset', fromsubclass_=False):
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.gates is not None:
            self.gates.export(outfile, level, namespace_, name_='gates', )
        if self.devices is not None:
            self.devices.export(outfile, level, namespace_, name_='devices', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.gates is not None or
            self.devices is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='deviceset'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uservalue is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            showIndent(outfile, level)
            outfile.write('uservalue = "%s",\n' % (self.uservalue,))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            showIndent(outfile, level)
            outfile.write('prefix = "%s",\n' % (self.prefix,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gates is not None:
            showIndent(outfile, level)
            outfile.write('gates=model_.gates(\n')
            self.gates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devices is not None:
            showIndent(outfile, level)
            outfile.write('devices=model_.devices(\n')
            self.devices.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uservalue', node)
        if value is not None and 'uservalue' not in already_processed:
            already_processed.append('uservalue')
            self.uservalue = value
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            self.prefix = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'gates':
            obj_ = gates.factory()
            obj_.build(child_)
            self.set_gates(obj_)
        elif nodeName_ == 'devices':
            obj_ = devices.factory()
            obj_.build(child_)
            self.set_devices(obj_)
# end class deviceset


class device(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, package=None, connects=None, technologies=None):
        self.name = _cast(None, name)
        self.package = _cast(None, package)
        self.connects = connects
        self.technologies = technologies
    def factory(*args_, **kwargs_):
        if device.subclass:
            return device.subclass(*args_, **kwargs_)
        else:
            return device(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connects(self): return self.connects
    def set_connects(self, connects): self.connects = connects
    def get_technologies(self): return self.technologies
    def set_technologies(self, technologies): self.technologies = technologies
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def export(self, outfile, level, namespace_='t:', name_='device', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='device')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='device'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            outfile.write(' package=%s' % (self.gds_format_string(quote_attrib(self.package).encode(ExternalEncoding), input_name='package'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='device', fromsubclass_=False):
        if self.connects is not None:
            self.connects.export(outfile, level, namespace_, name_='connects')
        if self.technologies is not None:
            self.technologies.export(outfile, level, namespace_, name_='technologies')
    def hasContent_(self):
        if (
            self.connects is not None or
            self.technologies is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='device'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            showIndent(outfile, level)
            outfile.write('package = "%s",\n' % (self.package,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connects is not None:
            showIndent(outfile, level)
            outfile.write('connects=model_.connects(\n')
            self.connects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.technologies is not None:
            showIndent(outfile, level)
            outfile.write('technologies=model_.technologies(\n')
            self.technologies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('package', node)
        if value is not None and 'package' not in already_processed:
            already_processed.append('package')
            self.package = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connects':
            obj_ = connects.factory()
            obj_.build(child_)
            self.set_connects(obj_)
        elif nodeName_ == 'technologies':
            obj_ = technologies.factory()
            obj_.build(child_)
            self.set_technologies(obj_)
# end class device


class bus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, segment=None):
        self.name = _cast(None, name)
        self.segment = segment
    def factory(*args_, **kwargs_):
        if bus.subclass:
            return bus.subclass(*args_, **kwargs_)
        else:
            return bus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='bus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='bus'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='bus', fromsubclass_=False):
        if self.segment is not None:
            self.segment.export(outfile, level, namespace_, name_='segment', )
    def hasContent_(self):
        if (
            self.segment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='bus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.segment is not None:
            showIndent(outfile, level)
            outfile.write('segment=model_.segment(\n')
            self.segment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.set_segment(obj_)
# end class bus


class net(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, classxx=None, segment=None):
        self.name = _cast(None, name)
        self.classxx = _cast(None, classxx)
        self.segment = segment
    def factory(*args_, **kwargs_):
        if net.subclass:
            return net.subclass(*args_, **kwargs_)
        else:
            return net(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='t:', name_='net', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='net')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='net'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='net', fromsubclass_=False):
        if self.segment is not None:
            self.segment.export(outfile, level, namespace_, name_='segment', )
    def hasContent_(self):
        if (
            self.segment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='net'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.segment is not None:
            showIndent(outfile, level)
            outfile.write('segment=model_.segment(\n')
            self.segment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segment.factory()
            obj_.build(child_)
            self.set_segment(obj_)
# end class net


class segment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pinref=None, wire=None, junction=None, label=None):
        if pinref is None:
            self.pinref = []
        else:
            self.pinref = pinref
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if junction is None:
            self.junction = []
        else:
            self.junction = junction
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if segment.subclass:
            return segment.subclass(*args_, **kwargs_)
        else:
            return segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pinref(self): return self.pinref
    def set_pinref(self, pinref): self.pinref = pinref
    def add_pinref(self, value): self.pinref.append(value)
    def insert_pinref(self, index, value): self.pinref[index] = value
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def add_wire(self, value): self.wire.append(value)
    def insert_wire(self, index, value): self.wire[index] = value
    def get_junction(self): return self.junction
    def set_junction(self, junction): self.junction = junction
    def add_junction(self, value): self.junction.append(value)
    def insert_junction(self, index, value): self.junction[index] = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label(self, index, value): self.label[index] = value
    def export(self, outfile, level, namespace_='t:', name_='segment', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segment')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='segment'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='segment', fromsubclass_=False):
        for pinref_ in self.pinref:
            pinref_.export(outfile, level, namespace_, name_='pinref')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for junction_ in self.junction:
            junction_.export(outfile, level, namespace_, name_='junction')
        for label_ in self.label:
            label_.export(outfile, level, namespace_, name_='label')
    def hasContent_(self):
        if (
            self.pinref or
            self.wire or
            self.junction or
            self.label
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='segment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pinref=[\n')
        level += 1
        for pinref_ in self.pinref:
            showIndent(outfile, level)
            outfile.write('model_.pinref(\n')
            pinref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('junction=[\n')
        level += 1
        for junction_ in self.junction:
            showIndent(outfile, level)
            outfile.write('model_.junction(\n')
            junction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('label=[\n')
        level += 1
        for label_ in self.label:
            showIndent(outfile, level)
            outfile.write('model_.label(\n')
            label_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pinref':
            obj_ = pinref.factory()
            obj_.build(child_)
            self.pinref.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'junction':
            obj_ = junction.factory()
            obj_.build(child_)
            self.junction.append(obj_)
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
# end class segment


class signal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, airwireshidden=None, name=None, classxx=None, contactref=None, polygon=None, wire=None, via=None):
        self.airwireshidden = _cast(None, airwireshidden)
        self.name = _cast(None, name)
        self.classxx = _cast(None, classxx)
        if contactref is None:
            self.contactref = []
        else:
            self.contactref = contactref
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if via is None:
            self.via = []
        else:
            self.via = via
    def factory(*args_, **kwargs_):
        if signal.subclass:
            return signal.subclass(*args_, **kwargs_)
        else:
            return signal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactref(self): return self.contactref
    def set_contactref(self, contactref): self.contactref = contactref
    def add_contactref(self, value): self.contactref.append(value)
    def insert_contactref(self, index, value): self.contactref[index] = value
    def get_polygon(self): return self.polygon
    def set_polygon(self, polygon): self.polygon = polygon
    def add_polygon(self, value): self.polygon.append(value)
    def insert_polygon(self, index, value): self.polygon[index] = value
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def add_wire(self, value): self.wire.append(value)
    def insert_wire(self, index, value): self.wire[index] = value
    def get_via(self): return self.via
    def set_via(self, via): self.via = via
    def add_via(self, value): self.via.append(value)
    def insert_via(self, index, value): self.via[index] = value
    def get_airwireshidden(self): return self.airwireshidden
    def set_airwireshidden(self, airwireshidden): self.airwireshidden = airwireshidden
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='t:', name_='signal', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signal')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='signal'):
        if self.airwireshidden is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            outfile.write(' airwireshidden=%s' % (self.gds_format_string(quote_attrib(self.airwireshidden).encode(ExternalEncoding), input_name='airwireshidden'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='signal', fromsubclass_=False):
        for contactref_ in self.contactref:
            contactref_.export(outfile, level, namespace_, name_='contactref')
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for via_ in self.via:
            via_.export(outfile, level, namespace_, name_='via')
    def hasContent_(self):
        if (
            self.contactref or
            self.polygon or
            self.wire or
            self.via
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='signal'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.airwireshidden is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            showIndent(outfile, level)
            outfile.write('airwireshidden = "%s",\n' % (self.airwireshidden,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contactref=[\n')
        level += 1
        for contactref_ in self.contactref:
            showIndent(outfile, level)
            outfile.write('model_.contactref(\n')
            contactref_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('via=[\n')
        level += 1
        for via_ in self.via:
            showIndent(outfile, level)
            outfile.write('model_.via(\n')
            via_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('airwireshidden', node)
        if value is not None and 'airwireshidden' not in already_processed:
            already_processed.append('airwireshidden')
            self.airwireshidden = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contactref':
            obj_ = contactref.factory()
            obj_.build(child_)
            self.contactref.append(obj_)
        elif nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'via':
            obj_ = via.factory()
            obj_.build(child_)
            self.via.append(obj_)
# end class signal


class variantdef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if variantdef.subclass:
            return variantdef.subclass(*args_, **kwargs_)
        else:
            return variantdef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='variantdef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variantdef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variantdef'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='variantdef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variantdef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class variantdef


class variant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, technology=None, name=None, populate=None):
        self.value = _cast(None, value)
        self.technology = _cast(None, technology)
        self.name = _cast(None, name)
        self.populate = _cast(None, populate)
        pass
    def factory(*args_, **kwargs_):
        if variant.subclass:
            return variant.subclass(*args_, **kwargs_)
        else:
            return variant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_technology(self): return self.technology
    def set_technology(self, technology): self.technology = technology
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_populate(self): return self.populate
    def set_populate(self, populate): self.populate = populate
    def export(self, outfile, level, namespace_='t:', name_='variant', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variant')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variant'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            outfile.write(' technology=%s' % (self.gds_format_string(quote_attrib(self.technology).encode(ExternalEncoding), input_name='technology'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.populate is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            outfile.write(' populate=%s' % (self.gds_format_string(quote_attrib(self.populate).encode(ExternalEncoding), input_name='populate'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='variant', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            showIndent(outfile, level)
            outfile.write('technology = "%s",\n' % (self.technology,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.populate is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            showIndent(outfile, level)
            outfile.write('populate = "%s",\n' % (self.populate,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('technology', node)
        if value is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            self.technology = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('populate', node)
        if value is not None and 'populate' not in already_processed:
            already_processed.append('populate')
            self.populate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class variant


class gate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, symbol=None, swaplevel=None, addlevel=None, y=None, x=None):
        self.name = _cast(None, name)
        self.symbol = _cast(None, symbol)
        self.swaplevel = _cast(None, swaplevel)
        self.addlevel = _cast(None, addlevel)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if gate.subclass:
            return gate.subclass(*args_, **kwargs_)
        else:
            return gate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def get_swaplevel(self): return self.swaplevel
    def set_swaplevel(self, swaplevel): self.swaplevel = swaplevel
    def get_addlevel(self): return self.addlevel
    def set_addlevel(self, addlevel): self.addlevel = addlevel
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def export(self, outfile, level, namespace_='t:', name_='gate', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gate')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='gate'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            outfile.write(' symbol=%s' % (self.gds_format_string(quote_attrib(self.symbol).encode(ExternalEncoding), input_name='symbol'), ))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            outfile.write(' swaplevel=%s' % (self.gds_format_string(quote_attrib(self.swaplevel).encode(ExternalEncoding), input_name='swaplevel'), ))
        if self.addlevel is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            outfile.write(' addlevel=%s' % (self.gds_format_string(quote_attrib(self.addlevel).encode(ExternalEncoding), input_name='addlevel'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='gate', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gate'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            showIndent(outfile, level)
            outfile.write('symbol = "%s",\n' % (self.symbol,))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            showIndent(outfile, level)
            outfile.write('swaplevel = "%s",\n' % (self.swaplevel,))
        if self.addlevel is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            showIndent(outfile, level)
            outfile.write('addlevel = "%s",\n' % (self.addlevel,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            self.symbol = value
        value = find_attr_value_('swaplevel', node)
        if value is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            self.swaplevel = value
        value = find_attr_value_('addlevel', node)
        if value is not None and 'addlevel' not in already_processed:
            already_processed.append('addlevel')
            self.addlevel = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gate


class wire(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, width=None, cap=None, curve=None, style=None, x2=None, extent=None, y1=None, x1=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.width = _cast(None, width)
        self.cap = _cast(None, cap)
        self.curve = _cast(None, curve)
        self.style = _cast(None, style)
        self.x2 = _cast(None, x2)
        self.extent = _cast(None, extent)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        pass
    def factory(*args_, **kwargs_):
        if wire.subclass:
            return wire.subclass(*args_, **kwargs_)
        else:
            return wire(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_y2(self): return self.y2
    def set_y2(self, y2): self.y2 = y2
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_cap(self): return self.cap
    def set_cap(self, cap): self.cap = cap
    def get_curve(self): return self.curve
    def set_curve(self, curve): self.curve = curve
    def get_style(self): return self.style
    def set_style(self, style): self.style = style
    def get_x2(self): return self.x2
    def set_x2(self, x2): self.x2 = x2
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def get_y1(self): return self.y1
    def set_y1(self, y1): self.y1 = y1
    def get_x1(self): return self.x1
    def set_x1(self, x1): self.x1 = x1
    def export(self, outfile, level, namespace_='t:', name_='wire', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wire')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='wire'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding), input_name='y2'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
        if self.cap is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            outfile.write(' cap=%s' % (self.gds_format_string(quote_attrib(self.cap).encode(ExternalEncoding), input_name='cap'), ))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            outfile.write(' curve=%s' % (self.gds_format_string(quote_attrib(self.curve).encode(ExternalEncoding), input_name='curve'), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            outfile.write(' style=%s' % (self.gds_format_string(quote_attrib(self.style).encode(ExternalEncoding), input_name='style'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding), input_name='x2'), ))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            outfile.write(' extent=%s' % (self.gds_format_string(quote_attrib(self.extent).encode(ExternalEncoding), input_name='extent'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding), input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding), input_name='x1'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='wire', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wire'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.cap is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            showIndent(outfile, level)
            outfile.write('cap = "%s",\n' % (self.cap,))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            showIndent(outfile, level)
            outfile.write('curve = "%s",\n' % (self.curve,))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            showIndent(outfile, level)
            outfile.write('style = "%s",\n' % (self.style,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            showIndent(outfile, level)
            outfile.write('extent = "%s",\n' % (self.extent,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('cap', node)
        if value is not None and 'cap' not in already_processed:
            already_processed.append('cap')
            self.cap = value
        value = find_attr_value_('curve', node)
        if value is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            self.curve = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.append('style')
            self.style = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('extent', node)
        if value is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            self.extent = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wire


class dimension(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, dtype=None, x2=None, y1=None, x3=None, y3=None, x1=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.dtype = _cast(None, dtype)
        self.x2 = _cast(None, x2)
        self.y1 = _cast(None, y1)
        self.x3 = _cast(None, x3)
        self.y3 = _cast(None, y3)
        self.x1 = _cast(None, x1)
        pass
    def factory(*args_, **kwargs_):
        if dimension.subclass:
            return dimension.subclass(*args_, **kwargs_)
        else:
            return dimension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_y2(self): return self.y2
    def set_y2(self, y2): self.y2 = y2
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def get_x2(self): return self.x2
    def set_x2(self, x2): self.x2 = x2
    def get_y1(self): return self.y1
    def set_y1(self, y1): self.y1 = y1
    def get_x3(self): return self.x3
    def set_x3(self, x3): self.x3 = x3
    def get_y3(self): return self.y3
    def set_y3(self, y3): self.y3 = y3
    def get_x1(self): return self.x1
    def set_x1(self, x1): self.x1 = x1
    def export(self, outfile, level, namespace_='t:', name_='dimension', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimension')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='dimension'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding), input_name='y2'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (self.gds_format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding), input_name='x2'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding), input_name='y1'), ))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            outfile.write(' x3=%s' % (self.gds_format_string(quote_attrib(self.x3).encode(ExternalEncoding), input_name='x3'), ))
        if self.y3 is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            outfile.write(' y3=%s' % (self.gds_format_string(quote_attrib(self.y3).encode(ExternalEncoding), input_name='y3'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding), input_name='x1'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='dimension', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dimension'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x3 is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            showIndent(outfile, level)
            outfile.write('x3 = "%s",\n' % (self.x3,))
        if self.y3 is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            showIndent(outfile, level)
            outfile.write('y3 = "%s",\n' % (self.y3,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('dtype', node)
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x3', node)
        if value is not None and 'x3' not in already_processed:
            already_processed.append('x3')
            self.x3 = value
        value = find_attr_value_('y3', node)
        if value is not None and 'y3' not in already_processed:
            already_processed.append('y3')
            self.y3 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimension


class text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, ratio=None, align=None, y=None, x=None, font=None, rot=None, size=None, valueOf_=None, mixedclass_=None, content_=None):
        self.layer = _cast(None, layer)
        self.ratio = _cast(None, ratio)
        self.align = _cast(None, align)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.size = _cast(None, size)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_ratio(self): return self.ratio
    def set_ratio(self, ratio): self.ratio = ratio
    def get_align(self): return self.align
    def set_align(self, align): self.align = align
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_font(self): return self.font
    def set_font(self, font): self.font = font
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='text', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='text'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding), input_name='ratio'), ))
        if self.align is not None and 'align' not in already_processed:
            already_processed.append('align')
            outfile.write(' align=%s' % (self.gds_format_string(quote_attrib(self.align).encode(ExternalEncoding), input_name='align'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding), input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding), input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='text', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='text'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.align is not None and 'align' not in already_processed:
            already_processed.append('align')
            showIndent(outfile, level)
            outfile.write('align = "%s",\n' % (self.align,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.append('align')
            self.align = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class text


class circle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, layer=None, radius=None, width=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.layer = _cast(None, layer)
        self.radius = _cast(None, radius)
        self.width = _cast(None, width)
        pass
    def factory(*args_, **kwargs_):
        if circle.subclass:
            return circle.subclass(*args_, **kwargs_)
        else:
            return circle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_radius(self): return self.radius
    def set_radius(self, radius): self.radius = radius
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def export(self, outfile, level, namespace_='t:', name_='circle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='circle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='circle'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            outfile.write(' radius=%s' % (self.gds_format_string(quote_attrib(self.radius).encode(ExternalEncoding), input_name='radius'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='circle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='circle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.radius is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            showIndent(outfile, level)
            outfile.write('radius = "%s",\n' % (self.radius,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('radius', node)
        if value is not None and 'radius' not in already_processed:
            already_processed.append('radius')
            self.radius = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class circle


class rectangle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, y2=None, x2=None, y1=None, x1=None, rot=None):
        self.layer = _cast(None, layer)
        self.y2 = _cast(None, y2)
        self.x2 = _cast(None, x2)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        self.rot = _cast(None, rot)
        pass
    def factory(*args_, **kwargs_):
        if rectangle.subclass:
            return rectangle.subclass(*args_, **kwargs_)
        else:
            return rectangle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_y2(self): return self.y2
    def set_y2(self, y2): self.y2 = y2
    def get_x2(self): return self.x2
    def set_x2(self, x2): self.x2 = x2
    def get_y1(self): return self.y1
    def set_y1(self, y1): self.y1 = y1
    def get_x1(self): return self.x1
    def set_x1(self, x1): self.x1 = x1
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='rectangle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rectangle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='rectangle'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding), input_name='y2'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding), input_name='x2'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding), input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding), input_name='x1'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='rectangle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rectangle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rectangle


class frame(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y2=None, layer=None, rows=None, border_right=None, border_bottom=None, x2=None, border_top=None, border_left=None, y1=None, x1=None, columns=None):
        self.y2 = _cast(None, y2)
        self.layer = _cast(None, layer)
        self.rows = _cast(None, rows)
        self.border_right = _cast(None, border_right)
        self.border_bottom = _cast(None, border_bottom)
        self.x2 = _cast(None, x2)
        self.border_top = _cast(None, border_top)
        self.border_left = _cast(None, border_left)
        self.y1 = _cast(None, y1)
        self.x1 = _cast(None, x1)
        self.columns = _cast(None, columns)
        pass
    def factory(*args_, **kwargs_):
        if frame.subclass:
            return frame.subclass(*args_, **kwargs_)
        else:
            return frame(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y2(self): return self.y2
    def set_y2(self, y2): self.y2 = y2
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_rows(self): return self.rows
    def set_rows(self, rows): self.rows = rows
    def get_border_right(self): return self.border_right
    def set_border_right(self, border_right): self.border_right = border_right
    def get_border_bottom(self): return self.border_bottom
    def set_border_bottom(self, border_bottom): self.border_bottom = border_bottom
    def get_x2(self): return self.x2
    def set_x2(self, x2): self.x2 = x2
    def get_border_top(self): return self.border_top
    def set_border_top(self, border_top): self.border_top = border_top
    def get_border_left(self): return self.border_left
    def set_border_left(self, border_left): self.border_left = border_left
    def get_y1(self): return self.y1
    def set_y1(self, y1): self.y1 = y1
    def get_x1(self): return self.x1
    def set_x1(self, x1): self.x1 = x1
    def get_columns(self): return self.columns
    def set_columns(self, columns): self.columns = columns
    def export(self, outfile, level, namespace_='t:', name_='frame', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='frame')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='frame'):
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            outfile.write(' y2=%s' % (self.gds_format_string(quote_attrib(self.y2).encode(ExternalEncoding), input_name='y2'), ))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            outfile.write(' rows=%s' % (self.gds_format_string(quote_attrib(self.rows).encode(ExternalEncoding), input_name='rows'), ))
        if self.border_right is not None and 'border_right' not in already_processed:
            already_processed.append('border_right')
            outfile.write(' border-right=%s' % (self.gds_format_string(quote_attrib(self.border_right).encode(ExternalEncoding), input_name='border-right'), ))
        if self.border_bottom is not None and 'border_bottom' not in already_processed:
            already_processed.append('border_bottom')
            outfile.write(' border-bottom=%s' % (self.gds_format_string(quote_attrib(self.border_bottom).encode(ExternalEncoding), input_name='border-bottom'), ))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            outfile.write(' x2=%s' % (self.gds_format_string(quote_attrib(self.x2).encode(ExternalEncoding), input_name='x2'), ))
        if self.border_top is not None and 'border_top' not in already_processed:
            already_processed.append('border_top')
            outfile.write(' border-top=%s' % (self.gds_format_string(quote_attrib(self.border_top).encode(ExternalEncoding), input_name='border-top'), ))
        if self.border_left is not None and 'border_left' not in already_processed:
            already_processed.append('border_left')
            outfile.write(' border-left=%s' % (self.gds_format_string(quote_attrib(self.border_left).encode(ExternalEncoding), input_name='border-left'), ))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            outfile.write(' y1=%s' % (self.gds_format_string(quote_attrib(self.y1).encode(ExternalEncoding), input_name='y1'), ))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            outfile.write(' x1=%s' % (self.gds_format_string(quote_attrib(self.x1).encode(ExternalEncoding), input_name='x1'), ))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            outfile.write(' columns=%s' % (self.gds_format_string(quote_attrib(self.columns).encode(ExternalEncoding), input_name='columns'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='frame', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='frame'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y2 is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            showIndent(outfile, level)
            outfile.write('y2 = "%s",\n' % (self.y2,))
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            showIndent(outfile, level)
            outfile.write('rows = "%s",\n' % (self.rows,))
        if self.border_right is not None and 'border_right' not in already_processed:
            already_processed.append('border_right')
            showIndent(outfile, level)
            outfile.write('border_right = "%s",\n' % (self.border_right,))
        if self.border_bottom is not None and 'border_bottom' not in already_processed:
            already_processed.append('border_bottom')
            showIndent(outfile, level)
            outfile.write('border_bottom = "%s",\n' % (self.border_bottom,))
        if self.x2 is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            showIndent(outfile, level)
            outfile.write('x2 = "%s",\n' % (self.x2,))
        if self.border_top is not None and 'border_top' not in already_processed:
            already_processed.append('border_top')
            showIndent(outfile, level)
            outfile.write('border_top = "%s",\n' % (self.border_top,))
        if self.border_left is not None and 'border_left' not in already_processed:
            already_processed.append('border_left')
            showIndent(outfile, level)
            outfile.write('border_left = "%s",\n' % (self.border_left,))
        if self.y1 is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            showIndent(outfile, level)
            outfile.write('y1 = "%s",\n' % (self.y1,))
        if self.x1 is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            showIndent(outfile, level)
            outfile.write('x1 = "%s",\n' % (self.x1,))
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            showIndent(outfile, level)
            outfile.write('columns = "%s",\n' % (self.columns,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y2', node)
        if value is not None and 'y2' not in already_processed:
            already_processed.append('y2')
            self.y2 = value
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('rows', node)
        if value is not None and 'rows' not in already_processed:
            already_processed.append('rows')
            self.rows = value
        value = find_attr_value_('border-right', node)
        if value is not None and 'border-right' not in already_processed:
            already_processed.append('border-right')
            self.border_right = value
        value = find_attr_value_('border-bottom', node)
        if value is not None and 'border-bottom' not in already_processed:
            already_processed.append('border-bottom')
            self.border_bottom = value
        value = find_attr_value_('x2', node)
        if value is not None and 'x2' not in already_processed:
            already_processed.append('x2')
            self.x2 = value
        value = find_attr_value_('border-top', node)
        if value is not None and 'border-top' not in already_processed:
            already_processed.append('border-top')
            self.border_top = value
        value = find_attr_value_('border-left', node)
        if value is not None and 'border-left' not in already_processed:
            already_processed.append('border-left')
            self.border_left = value
        value = find_attr_value_('y1', node)
        if value is not None and 'y1' not in already_processed:
            already_processed.append('y1')
            self.y1 = value
        value = find_attr_value_('x1', node)
        if value is not None and 'x1' not in already_processed:
            already_processed.append('x1')
            self.x1 = value
        value = find_attr_value_('columns', node)
        if value is not None and 'columns' not in already_processed:
            already_processed.append('columns')
            self.columns = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class frame


class hole(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, drill=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.drill = _cast(None, drill)
        pass
    def factory(*args_, **kwargs_):
        if hole.subclass:
            return hole.subclass(*args_, **kwargs_)
        else:
            return hole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_drill(self): return self.drill
    def set_drill(self, drill): self.drill = drill
    def export(self, outfile, level, namespace_='t:', name_='hole', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hole')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='hole'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding), input_name='drill'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='hole', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hole'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hole


class pad(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, diameter=None, thermals=None, name=None, stop=None, shape=None, drill=None, y=None, x=None, rot=None, first=None):
        self.diameter = _cast(None, diameter)
        self.thermals = _cast(None, thermals)
        self.name = _cast(None, name)
        self.stop = _cast(None, stop)
        self.shape = _cast(None, shape)
        self.drill = _cast(None, drill)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.first = _cast(None, first)
        pass
    def factory(*args_, **kwargs_):
        if pad.subclass:
            return pad.subclass(*args_, **kwargs_)
        else:
            return pad(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diameter(self): return self.diameter
    def set_diameter(self, diameter): self.diameter = diameter
    def get_thermals(self): return self.thermals
    def set_thermals(self, thermals): self.thermals = thermals
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_shape(self): return self.shape
    def set_shape(self, shape): self.shape = shape
    def get_drill(self): return self.drill
    def set_drill(self, drill): self.drill = drill
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_first(self): return self.first
    def set_first(self, first): self.first = first
    def export(self, outfile, level, namespace_='t:', name_='pad', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pad')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pad'):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter=%s' % (self.gds_format_string(quote_attrib(self.diameter).encode(ExternalEncoding), input_name='diameter'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding), input_name='thermals'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding), input_name='stop'), ))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (self.gds_format_string(quote_attrib(self.shape).encode(ExternalEncoding), input_name='shape'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding), input_name='drill'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.first is not None and 'first' not in already_processed:
            already_processed.append('first')
            outfile.write(' first=%s' % (self.gds_format_string(quote_attrib(self.first).encode(ExternalEncoding), input_name='first'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pad', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pad'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = "%s",\n' % (self.diameter,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            showIndent(outfile, level)
            outfile.write('stop = "%s",\n' % (self.stop,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.first is not None and 'first' not in already_processed:
            already_processed.append('first')
            showIndent(outfile, level)
            outfile.write('first = "%s",\n' % (self.first,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            self.diameter = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            self.stop = value
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('first', node)
        if value is not None and 'first' not in already_processed:
            already_processed.append('first')
            self.first = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pad


class smd(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, thermals=None, name=None, stop=None, roundness=None, dx=None, dy=None, y=None, x=None, rot=None, cream=None):
        self.layer = _cast(None, layer)
        self.thermals = _cast(None, thermals)
        self.name = _cast(None, name)
        self.stop = _cast(None, stop)
        self.roundness = _cast(None, roundness)
        self.dx = _cast(None, dx)
        self.dy = _cast(None, dy)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.cream = _cast(None, cream)
        pass
    def factory(*args_, **kwargs_):
        if smd.subclass:
            return smd.subclass(*args_, **kwargs_)
        else:
            return smd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_thermals(self): return self.thermals
    def set_thermals(self, thermals): self.thermals = thermals
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_stop(self): return self.stop
    def set_stop(self, stop): self.stop = stop
    def get_roundness(self): return self.roundness
    def set_roundness(self, roundness): self.roundness = roundness
    def get_dx(self): return self.dx
    def set_dx(self, dx): self.dx = dx
    def get_dy(self): return self.dy
    def set_dy(self, dy): self.dy = dy
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_cream(self): return self.cream
    def set_cream(self, cream): self.cream = cream
    def export(self, outfile, level, namespace_='t:', name_='smd', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smd')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='smd'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding), input_name='thermals'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            outfile.write(' stop=%s' % (self.gds_format_string(quote_attrib(self.stop).encode(ExternalEncoding), input_name='stop'), ))
        if self.roundness is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            outfile.write(' roundness=%s' % (self.gds_format_string(quote_attrib(self.roundness).encode(ExternalEncoding), input_name='roundness'), ))
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            outfile.write(' dx=%s' % (self.gds_format_string(quote_attrib(self.dx).encode(ExternalEncoding), input_name='dx'), ))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            outfile.write(' dy=%s' % (self.gds_format_string(quote_attrib(self.dy).encode(ExternalEncoding), input_name='dy'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.cream is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            outfile.write(' cream=%s' % (self.gds_format_string(quote_attrib(self.cream).encode(ExternalEncoding), input_name='cream'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='smd', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='smd'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.stop is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            showIndent(outfile, level)
            outfile.write('stop = "%s",\n' % (self.stop,))
        if self.roundness is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            showIndent(outfile, level)
            outfile.write('roundness = "%s",\n' % (self.roundness,))
        if self.dx is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            showIndent(outfile, level)
            outfile.write('dx = "%s",\n' % (self.dx,))
        if self.dy is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            showIndent(outfile, level)
            outfile.write('dy = "%s",\n' % (self.dy,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.cream is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            showIndent(outfile, level)
            outfile.write('cream = "%s",\n' % (self.cream,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('stop', node)
        if value is not None and 'stop' not in already_processed:
            already_processed.append('stop')
            self.stop = value
        value = find_attr_value_('roundness', node)
        if value is not None and 'roundness' not in already_processed:
            already_processed.append('roundness')
            self.roundness = value
        value = find_attr_value_('dx', node)
        if value is not None and 'dx' not in already_processed:
            already_processed.append('dx')
            self.dx = value
        value = find_attr_value_('dy', node)
        if value is not None and 'dy' not in already_processed:
            already_processed.append('dy')
            self.dy = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('cream', node)
        if value is not None and 'cream' not in already_processed:
            already_processed.append('cream')
            self.cream = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class smd


class element(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locked=None, name=None, package=None, value=None, smashed=None, library=None, y=None, x=None, rot=None, attribute=None, variant=None):
        self.locked = _cast(None, locked)
        self.name = _cast(None, name)
        self.package = _cast(None, package)
        self.value = _cast(None, value)
        self.smashed = _cast(None, smashed)
        self.library = _cast(None, library)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if variant is None:
            self.variant = []
        else:
            self.variant = variant
    def factory(*args_, **kwargs_):
        if element.subclass:
            return element.subclass(*args_, **kwargs_)
        else:
            return element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute(self, index, value): self.attribute[index] = value
    def get_variant(self): return self.variant
    def set_variant(self, variant): self.variant = variant
    def add_variant(self, value): self.variant.append(value)
    def insert_variant(self, index, value): self.variant[index] = value
    def get_locked(self): return self.locked
    def set_locked(self, locked): self.locked = locked
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_smashed(self): return self.smashed
    def set_smashed(self, smashed): self.smashed = smashed
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='element', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='element')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='element'):
        if self.locked is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            outfile.write(' locked=%s' % (self.gds_format_string(quote_attrib(self.locked).encode(ExternalEncoding), input_name='locked'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            outfile.write(' package=%s' % (self.gds_format_string(quote_attrib(self.package).encode(ExternalEncoding), input_name='package'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            outfile.write(' smashed=%s' % (self.gds_format_string(quote_attrib(self.smashed).encode(ExternalEncoding), input_name='smashed'), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            outfile.write(' library=%s' % (self.gds_format_string(quote_attrib(self.library).encode(ExternalEncoding), input_name='library'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='element', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
        for variant_ in self.variant:
            variant_.export(outfile, level, namespace_, name_='variant')
    def hasContent_(self):
        if (
            self.attribute or
            self.variant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='element'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locked is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            showIndent(outfile, level)
            outfile.write('locked = "%s",\n' % (self.locked,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            showIndent(outfile, level)
            outfile.write('package = "%s",\n' % (self.package,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            showIndent(outfile, level)
            outfile.write('smashed = "%s",\n' % (self.smashed,))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            showIndent(outfile, level)
            outfile.write('library = "%s",\n' % (self.library,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variant=[\n')
        level += 1
        for variant_ in self.variant:
            showIndent(outfile, level)
            outfile.write('model_.variant(\n')
            variant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locked', node)
        if value is not None and 'locked' not in already_processed:
            already_processed.append('locked')
            self.locked = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('package', node)
        if value is not None and 'package' not in already_processed:
            already_processed.append('package')
            self.package = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('smashed', node)
        if value is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            self.smashed = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.append('library')
            self.library = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
        elif nodeName_ == 'variant':
            obj_ = variant.factory()
            obj_.build(child_)
            self.variant.append(obj_)
# end class element


class via(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, diameter=None, extent=None, shape=None, alwaysstop=None, drill=None, y=None, x=None):
        self.diameter = _cast(None, diameter)
        self.extent = _cast(None, extent)
        self.shape = _cast(None, shape)
        self.alwaysstop = _cast(None, alwaysstop)
        self.drill = _cast(None, drill)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if via.subclass:
            return via.subclass(*args_, **kwargs_)
        else:
            return via(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diameter(self): return self.diameter
    def set_diameter(self, diameter): self.diameter = diameter
    def get_extent(self): return self.extent
    def set_extent(self, extent): self.extent = extent
    def get_shape(self): return self.shape
    def set_shape(self, shape): self.shape = shape
    def get_alwaysstop(self): return self.alwaysstop
    def set_alwaysstop(self, alwaysstop): self.alwaysstop = alwaysstop
    def get_drill(self): return self.drill
    def set_drill(self, drill): self.drill = drill
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def export(self, outfile, level, namespace_='t:', name_='via', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='via')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='via'):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            outfile.write(' diameter=%s' % (self.gds_format_string(quote_attrib(self.diameter).encode(ExternalEncoding), input_name='diameter'), ))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            outfile.write(' extent=%s' % (self.gds_format_string(quote_attrib(self.extent).encode(ExternalEncoding), input_name='extent'), ))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (self.gds_format_string(quote_attrib(self.shape).encode(ExternalEncoding), input_name='shape'), ))
        if self.alwaysstop is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            outfile.write(' alwaysstop=%s' % (self.gds_format_string(quote_attrib(self.alwaysstop).encode(ExternalEncoding), input_name='alwaysstop'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding), input_name='drill'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='via', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='via'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            showIndent(outfile, level)
            outfile.write('diameter = "%s",\n' % (self.diameter,))
        if self.extent is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            showIndent(outfile, level)
            outfile.write('extent = "%s",\n' % (self.extent,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.alwaysstop is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            showIndent(outfile, level)
            outfile.write('alwaysstop = "%s",\n' % (self.alwaysstop,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.append('diameter')
            self.diameter = value
        value = find_attr_value_('extent', node)
        if value is not None and 'extent' not in already_processed:
            already_processed.append('extent')
            self.extent = value
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
        value = find_attr_value_('alwaysstop', node)
        if value is not None and 'alwaysstop' not in already_processed:
            already_processed.append('alwaysstop')
            self.alwaysstop = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class via


class polygon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, thermals=None, spacing=None, orphans=None, isolate=None, pour=None, width=None, rank=None, vertex=None):
        self.layer = _cast(None, layer)
        self.thermals = _cast(None, thermals)
        self.spacing = _cast(None, spacing)
        self.orphans = _cast(None, orphans)
        self.isolate = _cast(None, isolate)
        self.pour = _cast(None, pour)
        self.width = _cast(None, width)
        self.rank = _cast(None, rank)
        self.vertex = vertex
    def factory(*args_, **kwargs_):
        if polygon.subclass:
            return polygon.subclass(*args_, **kwargs_)
        else:
            return polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vertex(self): return self.vertex
    def set_vertex(self, vertex): self.vertex = vertex
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_thermals(self): return self.thermals
    def set_thermals(self, thermals): self.thermals = thermals
    def get_spacing(self): return self.spacing
    def set_spacing(self, spacing): self.spacing = spacing
    def get_orphans(self): return self.orphans
    def set_orphans(self, orphans): self.orphans = orphans
    def get_isolate(self): return self.isolate
    def set_isolate(self, isolate): self.isolate = isolate
    def get_pour(self): return self.pour
    def set_pour(self, pour): self.pour = pour
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_rank(self): return self.rank
    def set_rank(self, rank): self.rank = rank
    def export(self, outfile, level, namespace_='t:', name_='polygon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='polygon')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='polygon'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            outfile.write(' thermals=%s' % (self.gds_format_string(quote_attrib(self.thermals).encode(ExternalEncoding), input_name='thermals'), ))
        if self.spacing is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            outfile.write(' spacing=%s' % (self.gds_format_string(quote_attrib(self.spacing).encode(ExternalEncoding), input_name='spacing'), ))
        if self.orphans is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            outfile.write(' orphans=%s' % (self.gds_format_string(quote_attrib(self.orphans).encode(ExternalEncoding), input_name='orphans'), ))
        if self.isolate is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            outfile.write(' isolate=%s' % (self.gds_format_string(quote_attrib(self.isolate).encode(ExternalEncoding), input_name='isolate'), ))
        if self.pour is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            outfile.write(' pour=%s' % (self.gds_format_string(quote_attrib(self.pour).encode(ExternalEncoding), input_name='pour'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            outfile.write(' rank=%s' % (self.gds_format_string(quote_attrib(self.rank).encode(ExternalEncoding), input_name='rank'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='polygon', fromsubclass_=False):
        if self.vertex is not None:
            self.vertex.export(outfile, level, namespace_, name_='vertex', )
    def hasContent_(self):
        if (
            self.vertex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='polygon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.thermals is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            showIndent(outfile, level)
            outfile.write('thermals = "%s",\n' % (self.thermals,))
        if self.spacing is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            showIndent(outfile, level)
            outfile.write('spacing = "%s",\n' % (self.spacing,))
        if self.orphans is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            showIndent(outfile, level)
            outfile.write('orphans = "%s",\n' % (self.orphans,))
        if self.isolate is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            showIndent(outfile, level)
            outfile.write('isolate = "%s",\n' % (self.isolate,))
        if self.pour is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            showIndent(outfile, level)
            outfile.write('pour = "%s",\n' % (self.pour,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.rank is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            showIndent(outfile, level)
            outfile.write('rank = "%s",\n' % (self.rank,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.vertex is not None:
            showIndent(outfile, level)
            outfile.write('vertex=model_.vertex(\n')
            self.vertex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('thermals', node)
        if value is not None and 'thermals' not in already_processed:
            already_processed.append('thermals')
            self.thermals = value
        value = find_attr_value_('spacing', node)
        if value is not None and 'spacing' not in already_processed:
            already_processed.append('spacing')
            self.spacing = value
        value = find_attr_value_('orphans', node)
        if value is not None and 'orphans' not in already_processed:
            already_processed.append('orphans')
            self.orphans = value
        value = find_attr_value_('isolate', node)
        if value is not None and 'isolate' not in already_processed:
            already_processed.append('isolate')
            self.isolate = value
        value = find_attr_value_('pour', node)
        if value is not None and 'pour' not in already_processed:
            already_processed.append('pour')
            self.pour = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.append('rank')
            self.rank = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vertex':
            obj_ = vertex.factory()
            obj_.build(child_)
            self.set_vertex(obj_)
# end class polygon


class vertex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, curve=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.curve = _cast(None, curve)
        pass
    def factory(*args_, **kwargs_):
        if vertex.subclass:
            return vertex.subclass(*args_, **kwargs_)
        else:
            return vertex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_curve(self): return self.curve
    def set_curve(self, curve): self.curve = curve
    def export(self, outfile, level, namespace_='t:', name_='vertex', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vertex')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='vertex'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            outfile.write(' curve=%s' % (self.gds_format_string(quote_attrib(self.curve).encode(ExternalEncoding), input_name='curve'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='vertex', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vertex'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.curve is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            showIndent(outfile, level)
            outfile.write('curve = "%s",\n' % (self.curve,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('curve', node)
        if value is not None and 'curve' not in already_processed:
            already_processed.append('curve')
            self.curve = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vertex


class pin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, function=None, direction=None, name=None, visible=None, length=None, y=None, x=None, rot=None, swaplevel=None):
        self.function = _cast(None, function)
        self.direction = _cast(None, direction)
        self.name = _cast(None, name)
        self.visible = _cast(None, visible)
        self.length = _cast(None, length)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.rot = _cast(None, rot)
        self.swaplevel = _cast(None, swaplevel)
        pass
    def factory(*args_, **kwargs_):
        if pin.subclass:
            return pin.subclass(*args_, **kwargs_)
        else:
            return pin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_visible(self): return self.visible
    def set_visible(self, visible): self.visible = visible
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_swaplevel(self): return self.swaplevel
    def set_swaplevel(self, swaplevel): self.swaplevel = swaplevel
    def export(self, outfile, level, namespace_='t:', name_='pin', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pin')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pin'):
        if self.function is not None and 'function' not in already_processed:
            already_processed.append('function')
            outfile.write(' function=%s' % (self.gds_format_string(quote_attrib(self.function).encode(ExternalEncoding), input_name='function'), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            outfile.write(' direction=%s' % (self.gds_format_string(quote_attrib(self.direction).encode(ExternalEncoding), input_name='direction'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            outfile.write(' visible=%s' % (self.gds_format_string(quote_attrib(self.visible).encode(ExternalEncoding), input_name='visible'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length=%s' % (self.gds_format_string(quote_attrib(self.length).encode(ExternalEncoding), input_name='length'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            outfile.write(' swaplevel=%s' % (self.gds_format_string(quote_attrib(self.swaplevel).encode(ExternalEncoding), input_name='swaplevel'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pin', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pin'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.function is not None and 'function' not in already_processed:
            already_processed.append('function')
            showIndent(outfile, level)
            outfile.write('function = "%s",\n' % (self.function,))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            showIndent(outfile, level)
            outfile.write('direction = "%s",\n' % (self.direction,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            showIndent(outfile, level)
            outfile.write('visible = "%s",\n' % (self.visible,))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = "%s",\n' % (self.length,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.swaplevel is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            showIndent(outfile, level)
            outfile.write('swaplevel = "%s",\n' % (self.swaplevel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.append('function')
            self.function = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            self.direction = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            self.visible = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            self.length = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('swaplevel', node)
        if value is not None and 'swaplevel' not in already_processed:
            already_processed.append('swaplevel')
            self.swaplevel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pin


class part(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, deviceset=None, value=None, library=None, device=None, technology=None, attribute=None, variant=None):
        self.name = _cast(None, name)
        self.deviceset = _cast(None, deviceset)
        self.value = _cast(None, value)
        self.library = _cast(None, library)
        self.device = _cast(None, device)
        self.technology = _cast(None, technology)
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if variant is None:
            self.variant = []
        else:
            self.variant = variant
    def factory(*args_, **kwargs_):
        if part.subclass:
            return part.subclass(*args_, **kwargs_)
        else:
            return part(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute(self, index, value): self.attribute[index] = value
    def get_variant(self): return self.variant
    def set_variant(self, variant): self.variant = variant
    def add_variant(self, value): self.variant.append(value)
    def insert_variant(self, index, value): self.variant[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_deviceset(self): return self.deviceset
    def set_deviceset(self, deviceset): self.deviceset = deviceset
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_technology(self): return self.technology
    def set_technology(self, technology): self.technology = technology
    def export(self, outfile, level, namespace_='t:', name_='part', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='part')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='part'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.deviceset is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            outfile.write(' deviceset=%s' % (self.gds_format_string(quote_attrib(self.deviceset).encode(ExternalEncoding), input_name='deviceset'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            outfile.write(' library=%s' % (self.gds_format_string(quote_attrib(self.library).encode(ExternalEncoding), input_name='library'), ))
        if self.device is not None and 'device' not in already_processed:
            already_processed.append('device')
            outfile.write(' device=%s' % (self.gds_format_string(quote_attrib(self.device).encode(ExternalEncoding), input_name='device'), ))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            outfile.write(' technology=%s' % (self.gds_format_string(quote_attrib(self.technology).encode(ExternalEncoding), input_name='technology'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='part', fromsubclass_=False):
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute')
        for variant_ in self.variant:
            variant_.export(outfile, level, namespace_, name_='variant')
    def hasContent_(self):
        if (
            self.attribute or
            self.variant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='part'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.deviceset is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            showIndent(outfile, level)
            outfile.write('deviceset = "%s",\n' % (self.deviceset,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.library is not None and 'library' not in already_processed:
            already_processed.append('library')
            showIndent(outfile, level)
            outfile.write('library = "%s",\n' % (self.library,))
        if self.device is not None and 'device' not in already_processed:
            already_processed.append('device')
            showIndent(outfile, level)
            outfile.write('device = "%s",\n' % (self.device,))
        if self.technology is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            showIndent(outfile, level)
            outfile.write('technology = "%s",\n' % (self.technology,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('variant=[\n')
        level += 1
        for variant_ in self.variant:
            showIndent(outfile, level)
            outfile.write('model_.variant(\n')
            variant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('deviceset', node)
        if value is not None and 'deviceset' not in already_processed:
            already_processed.append('deviceset')
            self.deviceset = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.append('library')
            self.library = value
        value = find_attr_value_('device', node)
        if value is not None and 'device' not in already_processed:
            already_processed.append('device')
            self.device = value
        value = find_attr_value_('technology', node)
        if value is not None and 'technology' not in already_processed:
            already_processed.append('technology')
            self.technology = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
        elif nodeName_ == 'variant':
            obj_ = variant.factory()
            obj_.build(child_)
            self.variant.append(obj_)
# end class part


class instance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, smashed=None, part=None, x=None, y=None, gate=None, rot=None, attribute=None):
        self.smashed = _cast(None, smashed)
        self.part = _cast(None, part)
        self.x = _cast(None, x)
        self.y = _cast(None, y)
        self.gate = _cast(None, gate)
        self.rot = _cast(None, rot)
        self.attribute = attribute
    def factory(*args_, **kwargs_):
        if instance.subclass:
            return instance.subclass(*args_, **kwargs_)
        else:
            return instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def get_smashed(self): return self.smashed
    def set_smashed(self, smashed): self.smashed = smashed
    def get_part(self): return self.part
    def set_part(self, part): self.part = part
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_gate(self): return self.gate
    def set_gate(self, gate): self.gate = gate
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def export(self, outfile, level, namespace_='t:', name_='instance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='instance'):
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            outfile.write(' smashed=%s' % (self.gds_format_string(quote_attrib(self.smashed).encode(ExternalEncoding), input_name='smashed'), ))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            outfile.write(' part=%s' % (self.gds_format_string(quote_attrib(self.part).encode(ExternalEncoding), input_name='part'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding), input_name='gate'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='instance', fromsubclass_=False):
        if self.attribute is not None:
            self.attribute.export(outfile, level, namespace_, name_='attribute', )
    def hasContent_(self):
        if (
            self.attribute is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='instance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.smashed is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            showIndent(outfile, level)
            outfile.write('smashed = "%s",\n' % (self.smashed,))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            showIndent(outfile, level)
            outfile.write('part = "%s",\n' % (self.part,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=model_.attribute(\n')
            self.attribute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smashed', node)
        if value is not None and 'smashed' not in already_processed:
            already_processed.append('smashed')
            self.smashed = value
        value = find_attr_value_('part', node)
        if value is not None and 'part' not in already_processed:
            already_processed.append('part')
            self.part = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.set_attribute(obj_)
# end class instance


class label(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, xref=None, ratio=None, y=None, x=None, font=None, rot=None, size=None):
        self.layer = _cast(None, layer)
        self.xref = _cast(None, xref)
        self.ratio = _cast(None, ratio)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.size = _cast(None, size)
        pass
    def factory(*args_, **kwargs_):
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_xref(self): return self.xref
    def set_xref(self, xref): self.xref = xref
    def get_ratio(self): return self.ratio
    def set_ratio(self, ratio): self.ratio = ratio
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_font(self): return self.font
    def set_font(self, font): self.font = font
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def export(self, outfile, level, namespace_='t:', name_='label', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='label'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.xref is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            outfile.write(' xref=%s' % (self.gds_format_string(quote_attrib(self.xref).encode(ExternalEncoding), input_name='xref'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding), input_name='ratio'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding), input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding), input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='label', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='label'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.xref is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            showIndent(outfile, level)
            outfile.write('xref = "%s",\n' % (self.xref,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('xref', node)
        if value is not None and 'xref' not in already_processed:
            already_processed.append('xref')
            self.xref = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class label


class junction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None):
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        pass
    def factory(*args_, **kwargs_):
        if junction.subclass:
            return junction.subclass(*args_, **kwargs_)
        else:
            return junction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def export(self, outfile, level, namespace_='t:', name_='junction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='junction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='junction'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='junction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='junction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class junction


class connect(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None, route=None, pad=None, pin=None):
        self.gate = _cast(None, gate)
        self.route = _cast(None, route)
        self.pad = _cast(None, pad)
        self.pin = _cast(None, pin)
        pass
    def factory(*args_, **kwargs_):
        if connect.subclass:
            return connect.subclass(*args_, **kwargs_)
        else:
            return connect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self): return self.gate
    def set_gate(self, gate): self.gate = gate
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_pad(self): return self.pad
    def set_pad(self, pad): self.pad = pad
    def get_pin(self): return self.pin
    def set_pin(self, pin): self.pin = pin
    def export(self, outfile, level, namespace_='t:', name_='connect', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connect')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='connect'):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding), input_name='gate'), ))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            outfile.write(' route=%s' % (self.gds_format_string(quote_attrib(self.route).encode(ExternalEncoding), input_name='route'), ))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            outfile.write(' pad=%s' % (self.gds_format_string(quote_attrib(self.pad).encode(ExternalEncoding), input_name='pad'), ))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            outfile.write(' pin=%s' % (self.gds_format_string(quote_attrib(self.pin).encode(ExternalEncoding), input_name='pin'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='connect', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connect'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            showIndent(outfile, level)
            outfile.write('route = "%s",\n' % (self.route,))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            showIndent(outfile, level)
            outfile.write('pad = "%s",\n' % (self.pad,))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            showIndent(outfile, level)
            outfile.write('pin = "%s",\n' % (self.pin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('route', node)
        if value is not None and 'route' not in already_processed:
            already_processed.append('route')
            self.route = value
        value = find_attr_value_('pad', node)
        if value is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            self.pad = value
        value = find_attr_value_('pin', node)
        if value is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            self.pin = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class connect


class technology(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, attribute=None):
        self.name = _cast(None, name)
        self.attribute = attribute
    def factory(*args_, **kwargs_):
        if technology.subclass:
            return technology.subclass(*args_, **kwargs_)
        else:
            return technology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='technology', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technology')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='technology'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='technology', fromsubclass_=False):
        if self.attribute is not None:
            self.attribute.export(outfile, level, namespace_, name_='attribute', )
    def hasContent_(self):
        if (
            self.attribute is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='technology'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=model_.attribute(\n')
            self.attribute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.set_attribute(obj_)
# end class technology


class attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None, ratio=None, name=None, value=None, y=None, x=None, constant=None, font=None, rot=None, display=None, size=None):
        self.layer = _cast(None, layer)
        self.ratio = _cast(None, ratio)
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.constant = _cast(None, constant)
        self.font = _cast(None, font)
        self.rot = _cast(None, rot)
        self.display = _cast(None, display)
        self.size = _cast(None, size)
        pass
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def get_ratio(self): return self.ratio
    def set_ratio(self, ratio): self.ratio = ratio
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_font(self): return self.font
    def set_font(self, font): self.font = font
    def get_rot(self): return self.rot
    def set_rot(self, rot): self.rot = rot
    def get_display(self): return self.display
    def set_display(self, display): self.display = display
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def export(self, outfile, level, namespace_='t:', name_='attribute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='attribute'):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            outfile.write(' layer=%s' % (self.gds_format_string(quote_attrib(self.layer).encode(ExternalEncoding), input_name='layer'), ))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            outfile.write(' ratio=%s' % (self.gds_format_string(quote_attrib(self.ratio).encode(ExternalEncoding), input_name='ratio'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            outfile.write(' constant=%s' % (self.gds_format_string(quote_attrib(self.constant).encode(ExternalEncoding), input_name='constant'), ))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            outfile.write(' font=%s' % (self.gds_format_string(quote_attrib(self.font).encode(ExternalEncoding), input_name='font'), ))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            outfile.write(' rot=%s' % (self.gds_format_string(quote_attrib(self.rot).encode(ExternalEncoding), input_name='rot'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding), input_name='display'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size=%s' % (self.gds_format_string(quote_attrib(self.size).encode(ExternalEncoding), input_name='size'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='attribute', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.layer is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            showIndent(outfile, level)
            outfile.write('layer = "%s",\n' % (self.layer,))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            showIndent(outfile, level)
            outfile.write('ratio = "%s",\n' % (self.ratio,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = "%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = "%s",\n' % (self.x,))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            showIndent(outfile, level)
            outfile.write('constant = "%s",\n' % (self.constant,))
        if self.font is not None and 'font' not in already_processed:
            already_processed.append('font')
            showIndent(outfile, level)
            outfile.write('font = "%s",\n' % (self.font,))
        if self.rot is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            showIndent(outfile, level)
            outfile.write('rot = "%s",\n' % (self.rot,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            showIndent(outfile, level)
            outfile.write('display = "%s",\n' % (self.display,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = "%s",\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('layer', node)
        if value is not None and 'layer' not in already_processed:
            already_processed.append('layer')
            self.layer = value
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.append('ratio')
            self.ratio = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            self.x = value
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            self.constant = value
        value = find_attr_value_('font', node)
        if value is not None and 'font' not in already_processed:
            already_processed.append('font')
            self.font = value
        value = find_attr_value_('rot', node)
        if value is not None and 'rot' not in already_processed:
            already_processed.append('rot')
            self.rot = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.append('display')
            self.display = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            self.size = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attribute


class pinref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None, part=None, pin=None):
        self.gate = _cast(None, gate)
        self.part = _cast(None, part)
        self.pin = _cast(None, pin)
        pass
    def factory(*args_, **kwargs_):
        if pinref.subclass:
            return pinref.subclass(*args_, **kwargs_)
        else:
            return pinref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self): return self.gate
    def set_gate(self, gate): self.gate = gate
    def get_part(self): return self.part
    def set_part(self, part): self.part = part
    def get_pin(self): return self.pin
    def set_pin(self, pin): self.pin = pin
    def export(self, outfile, level, namespace_='t:', name_='pinref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pinref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pinref'):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            outfile.write(' gate=%s' % (self.gds_format_string(quote_attrib(self.gate).encode(ExternalEncoding), input_name='gate'), ))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            outfile.write(' part=%s' % (self.gds_format_string(quote_attrib(self.part).encode(ExternalEncoding), input_name='part'), ))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            outfile.write(' pin=%s' % (self.gds_format_string(quote_attrib(self.pin).encode(ExternalEncoding), input_name='pin'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pinref', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pinref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gate is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            showIndent(outfile, level)
            outfile.write('gate = "%s",\n' % (self.gate,))
        if self.part is not None and 'part' not in already_processed:
            already_processed.append('part')
            showIndent(outfile, level)
            outfile.write('part = "%s",\n' % (self.part,))
        if self.pin is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            showIndent(outfile, level)
            outfile.write('pin = "%s",\n' % (self.pin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gate', node)
        if value is not None and 'gate' not in already_processed:
            already_processed.append('gate')
            self.gate = value
        value = find_attr_value_('part', node)
        if value is not None and 'part' not in already_processed:
            already_processed.append('part')
            self.part = value
        value = find_attr_value_('pin', node)
        if value is not None and 'pin' not in already_processed:
            already_processed.append('pin')
            self.pin = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pinref


class contactref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, route=None, pad=None, element=None):
        self.route = _cast(None, route)
        self.pad = _cast(None, pad)
        self.element = _cast(None, element)
        pass
    def factory(*args_, **kwargs_):
        if contactref.subclass:
            return contactref.subclass(*args_, **kwargs_)
        else:
            return contactref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_route(self): return self.route
    def set_route(self, route): self.route = route
    def get_pad(self): return self.pad
    def set_pad(self, pad): self.pad = pad
    def get_element(self): return self.element
    def set_element(self, element): self.element = element
    def export(self, outfile, level, namespace_='t:', name_='contactref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contactref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='contactref'):
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            outfile.write(' route=%s' % (self.gds_format_string(quote_attrib(self.route).encode(ExternalEncoding), input_name='route'), ))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            outfile.write(' pad=%s' % (self.gds_format_string(quote_attrib(self.pad).encode(ExternalEncoding), input_name='pad'), ))
        if self.element is not None and 'element' not in already_processed:
            already_processed.append('element')
            outfile.write(' element=%s' % (self.gds_format_string(quote_attrib(self.element).encode(ExternalEncoding), input_name='element'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='contactref', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contactref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.route is not None and 'route' not in already_processed:
            already_processed.append('route')
            showIndent(outfile, level)
            outfile.write('route = "%s",\n' % (self.route,))
        if self.pad is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            showIndent(outfile, level)
            outfile.write('pad = "%s",\n' % (self.pad,))
        if self.element is not None and 'element' not in already_processed:
            already_processed.append('element')
            showIndent(outfile, level)
            outfile.write('element = "%s",\n' % (self.element,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('route', node)
        if value is not None and 'route' not in already_processed:
            already_processed.append('route')
            self.route = value
        value = find_attr_value_('pad', node)
        if value is not None and 'pad' not in already_processed:
            already_processed.append('pad')
            self.pad = value
        value = find_attr_value_('element', node)
        if value is not None and 'element' not in already_processed:
            already_processed.append('element')
            self.element = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contactref


class variantdefs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variantdef=None):
        self.variantdef = variantdef
    def factory(*args_, **kwargs_):
        if variantdefs.subclass:
            return variantdefs.subclass(*args_, **kwargs_)
        else:
            return variantdefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variantdef(self): return self.variantdef
    def set_variantdef(self, variantdef): self.variantdef = variantdef
    def export(self, outfile, level, namespace_='t:', name_='variantdefs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='variantdefs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='variantdefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='variantdefs', fromsubclass_=False):
        if self.variantdef is not None:
            self.variantdef.export(outfile, level, namespace_, name_='variantdef', )
    def hasContent_(self):
        if (
            self.variantdef is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='variantdefs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.variantdef is not None:
            showIndent(outfile, level)
            outfile.write('variantdef=model_.variantdef(\n')
            self.variantdef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variantdef':
            obj_ = variantdef.factory()
            obj_.build(child_)
            self.set_variantdef(obj_)
# end class variantdefs


class settings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setting=None):
        self.setting = setting
    def factory(*args_, **kwargs_):
        if settings.subclass:
            return settings.subclass(*args_, **kwargs_)
        else:
            return settings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setting(self): return self.setting
    def set_setting(self, setting): self.setting = setting
    def export(self, outfile, level, namespace_='t:', name_='settings', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='settings')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='settings'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='settings', fromsubclass_=False):
        if self.setting is not None:
            self.setting.export(outfile, level, namespace_, name_='setting', )
    def hasContent_(self):
        if (
            self.setting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='settings'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.setting is not None:
            showIndent(outfile, level)
            outfile.write('setting=model_.setting(\n')
            self.setting.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'setting':
            obj_ = setting.factory()
            obj_.build(child_)
            self.set_setting(obj_)
# end class settings


class sheets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sheet=None):
        self.sheet = sheet
    def factory(*args_, **kwargs_):
        if sheets.subclass:
            return sheets.subclass(*args_, **kwargs_)
        else:
            return sheets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sheet(self): return self.sheet
    def set_sheet(self, sheet): self.sheet = sheet
    def export(self, outfile, level, namespace_='t:', name_='sheets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sheets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='sheets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='sheets', fromsubclass_=False):
        if self.sheet is not None:
            self.sheet.export(outfile, level, namespace_, name_='sheet', )
    def hasContent_(self):
        if (
            self.sheet is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sheets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.sheet is not None:
            showIndent(outfile, level)
            outfile.write('sheet=model_.sheet(\n')
            self.sheet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sheet':
            obj_ = sheet.factory()
            obj_.build(child_)
            self.set_sheet(obj_)
# end class sheets


class layers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None):
        self.layer = layer
    def factory(*args_, **kwargs_):
        if layers.subclass:
            return layers.subclass(*args_, **kwargs_)
        else:
            return layers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def export(self, outfile, level, namespace_='t:', name_='layers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='layers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='layers'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='layers', fromsubclass_=False):
        if self.layer is not None:
            self.layer.export(outfile, level, namespace_, name_='layer', )
    def hasContent_(self):
        if (
            self.layer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='layers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.layer is not None:
            showIndent(outfile, level)
            outfile.write('layer=model_.layer(\n')
            self.layer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'layer':
            obj_ = layer.factory()
            obj_.build(child_)
            self.set_layer(obj_)
# end class layers


class packages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, package=None):
        self.package = package
    def factory(*args_, **kwargs_):
        if packages.subclass:
            return packages.subclass(*args_, **kwargs_)
        else:
            return packages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def export(self, outfile, level, namespace_='t:', name_='packages', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='packages')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='packages'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='packages', fromsubclass_=False):
        if self.package is not None:
            self.package.export(outfile, level, namespace_, name_='package', )
    def hasContent_(self):
        if (
            self.package is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='packages'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.package is not None:
            showIndent(outfile, level)
            outfile.write('package=model_.package(\n')
            self.package.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'package':
            obj_ = package.factory()
            obj_.build(child_)
            self.set_package(obj_)
# end class packages


class symbols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, symbol=None):
        self.symbol = symbol
    def factory(*args_, **kwargs_):
        if symbols.subclass:
            return symbols.subclass(*args_, **kwargs_)
        else:
            return symbols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def export(self, outfile, level, namespace_='t:', name_='symbols', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='symbols')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='symbols'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='symbols', fromsubclass_=False):
        if self.symbol is not None:
            self.symbol.export(outfile, level, namespace_, name_='symbol', )
    def hasContent_(self):
        if (
            self.symbol is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='symbols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol=model_.symbol(\n')
            self.symbol.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'symbol':
            obj_ = symbol.factory()
            obj_.build(child_)
            self.set_symbol(obj_)
# end class symbols


class devicesets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deviceset=None):
        self.deviceset = deviceset
    def factory(*args_, **kwargs_):
        if devicesets.subclass:
            return devicesets.subclass(*args_, **kwargs_)
        else:
            return devicesets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceset(self): return self.deviceset
    def set_deviceset(self, deviceset): self.deviceset = deviceset
    def export(self, outfile, level, namespace_='t:', name_='devicesets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='devicesets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='devicesets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='devicesets', fromsubclass_=False):
        if self.deviceset is not None:
            self.deviceset.export(outfile, level, namespace_, name_='deviceset', )
    def hasContent_(self):
        if (
            self.deviceset is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='devicesets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.deviceset is not None:
            showIndent(outfile, level)
            outfile.write('deviceset=model_.deviceset(\n')
            self.deviceset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceset':
            obj_ = deviceset.factory()
            obj_.build(child_)
            self.set_deviceset(obj_)
# end class devicesets


class gates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gate=None):
        self.gate = gate
    def factory(*args_, **kwargs_):
        if gates.subclass:
            return gates.subclass(*args_, **kwargs_)
        else:
            return gates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gate(self): return self.gate
    def set_gate(self, gate): self.gate = gate
    def export(self, outfile, level, namespace_='t:', name_='gates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='gates'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='gates', fromsubclass_=False):
        if self.gate is not None:
            self.gate.export(outfile, level, namespace_, name_='gate', )
    def hasContent_(self):
        if (
            self.gate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.gate is not None:
            showIndent(outfile, level)
            outfile.write('gate=model_.gate(\n')
            self.gate.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gate':
            obj_ = gate.factory()
            obj_.build(child_)
            self.set_gate(obj_)
# end class gates


class devices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, device=None):
        self.device = device
    def factory(*args_, **kwargs_):
        if devices.subclass:
            return devices.subclass(*args_, **kwargs_)
        else:
            return devices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def export(self, outfile, level, namespace_='t:', name_='devices', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='devices')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='devices'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='devices', fromsubclass_=False):
        if self.device is not None:
            self.device.export(outfile, level, namespace_, name_='device', )
    def hasContent_(self):
        if (
            self.device is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='devices'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=model_.device(\n')
            self.device.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'device':
            obj_ = device.factory()
            obj_.build(child_)
            self.set_device(obj_)
# end class devices


class libraries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, library=None):
        self.library = library
    def factory(*args_, **kwargs_):
        if libraries.subclass:
            return libraries.subclass(*args_, **kwargs_)
        else:
            return libraries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def export(self, outfile, level, namespace_='t:', name_='libraries', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='libraries')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='libraries'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='libraries', fromsubclass_=False):
        if self.library is not None:
            self.library.export(outfile, level, namespace_, name_='library', )
    def hasContent_(self):
        if (
            self.library is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='libraries'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.library is not None:
            showIndent(outfile, level)
            outfile.write('library=model_.library(\n')
            self.library.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'library':
            obj_ = library.factory()
            obj_.build(child_)
            self.set_library(obj_)
# end class libraries


class connects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connect=None):
        self.connect = connect
    def factory(*args_, **kwargs_):
        if connects.subclass:
            return connects.subclass(*args_, **kwargs_)
        else:
            return connects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connect(self): return self.connect
    def set_connect(self, connect): self.connect = connect
    def export(self, outfile, level, namespace_='t:', name_='connects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='connects'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='connects', fromsubclass_=False):
        if self.connect is not None:
            self.connect.export(outfile, level, namespace_, name_='connect', )
    def hasContent_(self):
        if (
            self.connect is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connect is not None:
            showIndent(outfile, level)
            outfile.write('connect=model_.connect(\n')
            self.connect.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'connect':
            obj_ = connect.factory()
            obj_.build(child_)
            self.set_connect(obj_)
# end class connects


class technologies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, technology=None):
        self.technology = technology
    def factory(*args_, **kwargs_):
        if technologies.subclass:
            return technologies.subclass(*args_, **kwargs_)
        else:
            return technologies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_technology(self): return self.technology
    def set_technology(self, technology): self.technology = technology
    def export(self, outfile, level, namespace_='t:', name_='technologies', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technologies')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='technologies'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='technologies', fromsubclass_=False):
        if self.technology is not None:
            self.technology.export(outfile, level, namespace_, name_='technology', )
    def hasContent_(self):
        if (
            self.technology is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='technologies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.technology is not None:
            showIndent(outfile, level)
            outfile.write('technology=model_.technology(\n')
            self.technology.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'technology':
            obj_ = technology.factory()
            obj_.build(child_)
            self.set_technology(obj_)
# end class technologies


class attributes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.attribute = attribute
    def factory(*args_, **kwargs_):
        if attributes.subclass:
            return attributes.subclass(*args_, **kwargs_)
        else:
            return attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def export(self, outfile, level, namespace_='t:', name_='attributes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='attributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='attributes', fromsubclass_=False):
        if self.attribute is not None:
            self.attribute.export(outfile, level, namespace_, name_='attribute', )
    def hasContent_(self):
        if (
            self.attribute is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='attributes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=model_.attribute(\n')
            self.attribute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.set_attribute(obj_)
# end class attributes


class classes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classxx=None):
        self.classxx = classxx
    def factory(*args_, **kwargs_):
        if classes.subclass:
            return classes.subclass(*args_, **kwargs_)
        else:
            return classes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='t:', name_='classes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='classes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='classes'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='classes', fromsubclass_=False):
        if self.classxx is not None:
            self.classxx.export(outfile, level, namespace_, name_='class', )
    def hasContent_(self):
        if (
            self.classxx is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.classxx is not None:
            showIndent(outfile, level)
            outfile.write('classxx=model_.classxx(\n')
            self.classxx.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'class':
            obj_ = classxx.factory()
            obj_.build(child_)
            self.set_class(obj_)
# end class classes


class parts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, part=None):
        self.part = part
    def factory(*args_, **kwargs_):
        if parts.subclass:
            return parts.subclass(*args_, **kwargs_)
        else:
            return parts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_part(self): return self.part
    def set_part(self, part): self.part = part
    def export(self, outfile, level, namespace_='t:', name_='parts', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parts')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='parts'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='parts', fromsubclass_=False):
        if self.part is not None:
            self.part.export(outfile, level, namespace_, name_='part', )
    def hasContent_(self):
        if (
            self.part is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='parts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.part is not None:
            showIndent(outfile, level)
            outfile.write('part=model_.part(\n')
            self.part.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'part':
            obj_ = part.factory()
            obj_.build(child_)
            self.set_part(obj_)
# end class parts


class instances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, instance=None):
        self.instance = instance
    def factory(*args_, **kwargs_):
        if instances.subclass:
            return instances.subclass(*args_, **kwargs_)
        else:
            return instances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def export(self, outfile, level, namespace_='t:', name_='instances', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instances')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='instances'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='instances', fromsubclass_=False):
        if self.instance is not None:
            self.instance.export(outfile, level, namespace_, name_='instance', )
    def hasContent_(self):
        if (
            self.instance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='instances'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.instance is not None:
            showIndent(outfile, level)
            outfile.write('instance=model_.instance(\n')
            self.instance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instance':
            obj_ = instance.factory()
            obj_.build(child_)
            self.set_instance(obj_)
# end class instances


class errors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approved=None):
        self.approved = approved
    def factory(*args_, **kwargs_):
        if errors.subclass:
            return errors.subclass(*args_, **kwargs_)
        else:
            return errors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approved(self): return self.approved
    def set_approved(self, approved): self.approved = approved
    def export(self, outfile, level, namespace_='t:', name_='errors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='errors')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='errors'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='errors', fromsubclass_=False):
        if self.approved is not None:
            self.approved.export(outfile, level, namespace_, name_='approved', )
    def hasContent_(self):
        if (
            self.approved is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.approved is not None:
            showIndent(outfile, level)
            outfile.write('approved=model_.approved(\n')
            self.approved.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approved':
            obj_ = approved.factory()
            obj_.build(child_)
            self.set_approved(obj_)
# end class errors


class plain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, polygon=None, wire=None, text=None, circle=None, rectangle=None, frame=None, hole=None):
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
        if wire is None:
            self.wire = []
        else:
            self.wire = wire
        if text is None:
            self.text = []
        else:
            self.text = text
        if circle is None:
            self.circle = []
        else:
            self.circle = circle
        if rectangle is None:
            self.rectangle = []
        else:
            self.rectangle = rectangle
        if frame is None:
            self.frame = []
        else:
            self.frame = frame
        if hole is None:
            self.hole = []
        else:
            self.hole = hole
    def factory(*args_, **kwargs_):
        if plain.subclass:
            return plain.subclass(*args_, **kwargs_)
        else:
            return plain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polygon(self): return self.polygon
    def set_polygon(self, polygon): self.polygon = polygon
    def add_polygon(self, value): self.polygon.append(value)
    def insert_polygon(self, index, value): self.polygon[index] = value
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def add_wire(self, value): self.wire.append(value)
    def insert_wire(self, index, value): self.wire[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text(self, index, value): self.text[index] = value
    def get_circle(self): return self.circle
    def set_circle(self, circle): self.circle = circle
    def add_circle(self, value): self.circle.append(value)
    def insert_circle(self, index, value): self.circle[index] = value
    def get_rectangle(self): return self.rectangle
    def set_rectangle(self, rectangle): self.rectangle = rectangle
    def add_rectangle(self, value): self.rectangle.append(value)
    def insert_rectangle(self, index, value): self.rectangle[index] = value
    def get_frame(self): return self.frame
    def set_frame(self, frame): self.frame = frame
    def add_frame(self, value): self.frame.append(value)
    def insert_frame(self, index, value): self.frame[index] = value
    def get_hole(self): return self.hole
    def set_hole(self, hole): self.hole = hole
    def add_hole(self, value): self.hole.append(value)
    def insert_hole(self, index, value): self.hole[index] = value
    def export(self, outfile, level, namespace_='t:', name_='plain', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='plain')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='plain'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='plain', fromsubclass_=False):
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespace_, name_='polygon')
        for wire_ in self.wire:
            wire_.export(outfile, level, namespace_, name_='wire')
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text')
        for circle_ in self.circle:
            circle_.export(outfile, level, namespace_, name_='circle')
        for rectangle_ in self.rectangle:
            rectangle_.export(outfile, level, namespace_, name_='rectangle')
        for frame_ in self.frame:
            frame_.export(outfile, level, namespace_, name_='frame')
        for hole_ in self.hole:
            hole_.export(outfile, level, namespace_, name_='hole')
    def hasContent_(self):
        if (
            self.polygon or
            self.wire or
            self.text or
            self.circle or
            self.rectangle or
            self.frame or
            self.hole
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='plain'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('polygon=[\n')
        level += 1
        for polygon_ in self.polygon:
            showIndent(outfile, level)
            outfile.write('model_.polygon(\n')
            polygon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wire=[\n')
        level += 1
        for wire_ in self.wire:
            showIndent(outfile, level)
            outfile.write('model_.wire(\n')
            wire_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('text=[\n')
        level += 1
        for text_ in self.text:
            showIndent(outfile, level)
            outfile.write('model_.text(\n')
            text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('circle=[\n')
        level += 1
        for circle_ in self.circle:
            showIndent(outfile, level)
            outfile.write('model_.circle(\n')
            circle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rectangle=[\n')
        level += 1
        for rectangle_ in self.rectangle:
            showIndent(outfile, level)
            outfile.write('model_.rectangle(\n')
            rectangle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('frame=[\n')
        level += 1
        for frame_ in self.frame:
            showIndent(outfile, level)
            outfile.write('model_.frame(\n')
            frame_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hole=[\n')
        level += 1
        for hole_ in self.hole:
            showIndent(outfile, level)
            outfile.write('model_.hole(\n')
            hole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = polygon.factory()
            obj_.build(child_)
            self.polygon.append(obj_)
        elif nodeName_ == 'wire':
            obj_ = wire.factory()
            obj_.build(child_)
            self.wire.append(obj_)
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text.append(obj_)
        elif nodeName_ == 'circle':
            obj_ = circle.factory()
            obj_.build(child_)
            self.circle.append(obj_)
        elif nodeName_ == 'rectangle':
            obj_ = rectangle.factory()
            obj_.build(child_)
            self.rectangle.append(obj_)
        elif nodeName_ == 'frame':
            obj_ = frame.factory()
            obj_.build(child_)
            self.frame.append(obj_)
        elif nodeName_ == 'hole':
            obj_ = hole.factory()
            obj_.build(child_)
            self.hole.append(obj_)
# end class plain


class designrules(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, param=None):
        if description is None:
            self.description = []
        else:
            self.description = description
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if designrules.subclass:
            return designrules.subclass(*args_, **kwargs_)
        else:
            return designrules(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param(self, index, value): self.param[index] = value
    def export(self, outfile, level, namespace_='t:', name_='designrules', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='designrules')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='designrules'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='designrules', fromsubclass_=False):
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description')
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param')
    def hasContent_(self):
        if (
            self.description or
            self.param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='designrules'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.description(\n')
            description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('param=[\n')
        level += 1
        for param_ in self.param:
            showIndent(outfile, level)
            outfile.write('model_.param(\n')
            param_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
# end class designrules


class autorouter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, passxx=None):
        self.passxx = passxx
    def factory(*args_, **kwargs_):
        if autorouter.subclass:
            return autorouter.subclass(*args_, **kwargs_)
        else:
            return autorouter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pass(self): return self.passxx
    def set_pass(self, passxx): self.passxx = passxx
    def export(self, outfile, level, namespace_='t:', name_='autorouter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='autorouter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='autorouter'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='autorouter', fromsubclass_=False):
        if self.passxx is not None:
            self.passxx.export(outfile, level, namespace_, name_='pass', )
    def hasContent_(self):
        if (
            self.passxx is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autorouter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.passxx is not None:
            showIndent(outfile, level)
            outfile.write('passxx=model_.passxx(\n')
            self.passxx.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pass':
            obj_ = passxx.factory()
            obj_.build(child_)
            self.set_pass(obj_)
# end class autorouter


class elements(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, element=None):
        self.element = element
    def factory(*args_, **kwargs_):
        if elements.subclass:
            return elements.subclass(*args_, **kwargs_)
        else:
            return elements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_element(self): return self.element
    def set_element(self, element): self.element = element
    def export(self, outfile, level, namespace_='t:', name_='elements', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elements')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='elements'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='elements', fromsubclass_=False):
        if self.element is not None:
            self.element.export(outfile, level, namespace_, name_='element', )
    def hasContent_(self):
        if (
            self.element is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='elements'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.element is not None:
            showIndent(outfile, level)
            outfile.write('element=model_.element(\n')
            self.element.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'element':
            obj_ = element.factory()
            obj_.build(child_)
            self.set_element(obj_)
# end class elements


class signals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, signal=None):
        self.signal = signal
    def factory(*args_, **kwargs_):
        if signals.subclass:
            return signals.subclass(*args_, **kwargs_)
        else:
            return signals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_signal(self): return self.signal
    def set_signal(self, signal): self.signal = signal
    def export(self, outfile, level, namespace_='t:', name_='signals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='signals'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='signals', fromsubclass_=False):
        if self.signal is not None:
            self.signal.export(outfile, level, namespace_, name_='signal', )
    def hasContent_(self):
        if (
            self.signal is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='signals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.signal is not None:
            showIndent(outfile, level)
            outfile.write('signal=model_.signal(\n')
            self.signal.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'signal':
            obj_ = signal.factory()
            obj_.build(child_)
            self.set_signal(obj_)
# end class signals


class busses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bus=None):
        self.bus = bus
    def factory(*args_, **kwargs_):
        if busses.subclass:
            return busses.subclass(*args_, **kwargs_)
        else:
            return busses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bus(self): return self.bus
    def set_bus(self, bus): self.bus = bus
    def export(self, outfile, level, namespace_='t:', name_='busses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='busses'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='busses', fromsubclass_=False):
        if self.bus is not None:
            self.bus.export(outfile, level, namespace_, name_='bus', )
    def hasContent_(self):
        if (
            self.bus is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='busses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.bus is not None:
            showIndent(outfile, level)
            outfile.write('bus=model_.bus(\n')
            self.bus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bus':
            obj_ = bus.factory()
            obj_.build(child_)
            self.set_bus(obj_)
# end class busses


class nets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, net=None):
        self.net = net
    def factory(*args_, **kwargs_):
        if nets.subclass:
            return nets.subclass(*args_, **kwargs_)
        else:
            return nets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_net(self): return self.net
    def set_net(self, net): self.net = net
    def export(self, outfile, level, namespace_='t:', name_='nets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='nets'):
        pass
    def exportChildren(self, outfile, level, namespace_='t:', name_='nets', fromsubclass_=False):
        if self.net is not None:
            self.net.export(outfile, level, namespace_, name_='net', )
    def hasContent_(self):
        if (
            self.net is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.net is not None:
            showIndent(outfile, level)
            outfile.write('net=model_.net(\n')
            self.net.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'net':
            obj_ = net.factory()
            obj_.build(child_)
            self.set_net(obj_)
# end class nets


class setting(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, alwaysvectorfont=None, verticaltext=None):
        self.alwaysvectorfont = _cast(None, alwaysvectorfont)
        self.verticaltext = _cast(None, verticaltext)
        pass
    def factory(*args_, **kwargs_):
        if setting.subclass:
            return setting.subclass(*args_, **kwargs_)
        else:
            return setting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alwaysvectorfont(self): return self.alwaysvectorfont
    def set_alwaysvectorfont(self, alwaysvectorfont): self.alwaysvectorfont = alwaysvectorfont
    def get_verticaltext(self): return self.verticaltext
    def set_verticaltext(self, verticaltext): self.verticaltext = verticaltext
    def export(self, outfile, level, namespace_='t:', name_='setting', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='setting')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='setting'):
        if self.alwaysvectorfont is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            outfile.write(' alwaysvectorfont=%s' % (self.gds_format_string(quote_attrib(self.alwaysvectorfont).encode(ExternalEncoding), input_name='alwaysvectorfont'), ))
        if self.verticaltext is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            outfile.write(' verticaltext=%s' % (self.gds_format_string(quote_attrib(self.verticaltext).encode(ExternalEncoding), input_name='verticaltext'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='setting', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='setting'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.alwaysvectorfont is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            showIndent(outfile, level)
            outfile.write('alwaysvectorfont = "%s",\n' % (self.alwaysvectorfont,))
        if self.verticaltext is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            showIndent(outfile, level)
            outfile.write('verticaltext = "%s",\n' % (self.verticaltext,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alwaysvectorfont', node)
        if value is not None and 'alwaysvectorfont' not in already_processed:
            already_processed.append('alwaysvectorfont')
            self.alwaysvectorfont = value
        value = find_attr_value_('verticaltext', node)
        if value is not None and 'verticaltext' not in already_processed:
            already_processed.append('verticaltext')
            self.verticaltext = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class setting


class grid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, distance=None, style=None, multiple=None, altdistance=None, altunit=None, unitdist=None, altunitdist=None, display=None, unit=None):
        self.distance = _cast(None, distance)
        self.style = _cast(None, style)
        self.multiple = _cast(None, multiple)
        self.altdistance = _cast(None, altdistance)
        self.altunit = _cast(None, altunit)
        self.unitdist = _cast(None, unitdist)
        self.altunitdist = _cast(None, altunitdist)
        self.display = _cast(None, display)
        self.unit = _cast(None, unit)
        pass
    def factory(*args_, **kwargs_):
        if grid.subclass:
            return grid.subclass(*args_, **kwargs_)
        else:
            return grid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_distance(self): return self.distance
    def set_distance(self, distance): self.distance = distance
    def get_style(self): return self.style
    def set_style(self, style): self.style = style
    def get_multiple(self): return self.multiple
    def set_multiple(self, multiple): self.multiple = multiple
    def get_altdistance(self): return self.altdistance
    def set_altdistance(self, altdistance): self.altdistance = altdistance
    def get_altunit(self): return self.altunit
    def set_altunit(self, altunit): self.altunit = altunit
    def get_unitdist(self): return self.unitdist
    def set_unitdist(self, unitdist): self.unitdist = unitdist
    def get_altunitdist(self): return self.altunitdist
    def set_altunitdist(self, altunitdist): self.altunitdist = altunitdist
    def get_display(self): return self.display
    def set_display(self, display): self.display = display
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='t:', name_='grid', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='grid')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='grid'):
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            outfile.write(' distance=%s' % (self.gds_format_string(quote_attrib(self.distance).encode(ExternalEncoding), input_name='distance'), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            outfile.write(' style=%s' % (self.gds_format_string(quote_attrib(self.style).encode(ExternalEncoding), input_name='style'), ))
        if self.multiple is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            outfile.write(' multiple=%s' % (self.gds_format_string(quote_attrib(self.multiple).encode(ExternalEncoding), input_name='multiple'), ))
        if self.altdistance is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            outfile.write(' altdistance=%s' % (self.gds_format_string(quote_attrib(self.altdistance).encode(ExternalEncoding), input_name='altdistance'), ))
        if self.altunit is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            outfile.write(' altunit=%s' % (self.gds_format_string(quote_attrib(self.altunit).encode(ExternalEncoding), input_name='altunit'), ))
        if self.unitdist is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            outfile.write(' unitdist=%s' % (self.gds_format_string(quote_attrib(self.unitdist).encode(ExternalEncoding), input_name='unitdist'), ))
        if self.altunitdist is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            outfile.write(' altunitdist=%s' % (self.gds_format_string(quote_attrib(self.altunitdist).encode(ExternalEncoding), input_name='altunitdist'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding), input_name='display'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='grid', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='grid'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            showIndent(outfile, level)
            outfile.write('distance = "%s",\n' % (self.distance,))
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            showIndent(outfile, level)
            outfile.write('style = "%s",\n' % (self.style,))
        if self.multiple is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            showIndent(outfile, level)
            outfile.write('multiple = "%s",\n' % (self.multiple,))
        if self.altdistance is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            showIndent(outfile, level)
            outfile.write('altdistance = "%s",\n' % (self.altdistance,))
        if self.altunit is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            showIndent(outfile, level)
            outfile.write('altunit = "%s",\n' % (self.altunit,))
        if self.unitdist is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            showIndent(outfile, level)
            outfile.write('unitdist = "%s",\n' % (self.unitdist,))
        if self.altunitdist is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            showIndent(outfile, level)
            outfile.write('altunitdist = "%s",\n' % (self.altunitdist,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            showIndent(outfile, level)
            outfile.write('display = "%s",\n' % (self.display,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.append('distance')
            self.distance = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.append('style')
            self.style = value
        value = find_attr_value_('multiple', node)
        if value is not None and 'multiple' not in already_processed:
            already_processed.append('multiple')
            self.multiple = value
        value = find_attr_value_('altdistance', node)
        if value is not None and 'altdistance' not in already_processed:
            already_processed.append('altdistance')
            self.altdistance = value
        value = find_attr_value_('altunit', node)
        if value is not None and 'altunit' not in already_processed:
            already_processed.append('altunit')
            self.altunit = value
        value = find_attr_value_('unitdist', node)
        if value is not None and 'unitdist' not in already_processed:
            already_processed.append('unitdist')
            self.unitdist = value
        value = find_attr_value_('altunitdist', node)
        if value is not None and 'altunitdist' not in already_processed:
            already_processed.append('altunitdist')
            self.altunitdist = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.append('display')
            self.display = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class grid


class layer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, color=None, number=None, visible=None, active=None, fill=None):
        self.name = _cast(None, name)
        self.color = _cast(None, color)
        self.number = _cast(None, number)
        self.visible = _cast(None, visible)
        self.active = _cast(None, active)
        self.fill = _cast(None, fill)
        pass
    def factory(*args_, **kwargs_):
        if layer.subclass:
            return layer.subclass(*args_, **kwargs_)
        else:
            return layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_visible(self): return self.visible
    def set_visible(self, visible): self.visible = visible
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_fill(self): return self.fill
    def set_fill(self, fill): self.fill = fill
    def export(self, outfile, level, namespace_='t:', name_='layer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='layer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='layer'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding), input_name='color'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding), input_name='number'), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            outfile.write(' visible=%s' % (self.gds_format_string(quote_attrib(self.visible).encode(ExternalEncoding), input_name='visible'), ))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (self.gds_format_string(quote_attrib(self.active).encode(ExternalEncoding), input_name='active'), ))
        if self.fill is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            outfile.write(' fill=%s' % (self.gds_format_string(quote_attrib(self.fill).encode(ExternalEncoding), input_name='fill'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='layer', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='layer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            showIndent(outfile, level)
            outfile.write('color = "%s",\n' % (self.color,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = "%s",\n' % (self.number,))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            showIndent(outfile, level)
            outfile.write('visible = "%s",\n' % (self.visible,))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = "%s",\n' % (self.active,))
        if self.fill is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            showIndent(outfile, level)
            outfile.write('fill = "%s",\n' % (self.fill,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.append('color')
            self.color = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            self.number = value
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.append('visible')
            self.visible = value
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('fill', node)
        if value is not None and 'fill' not in already_processed:
            already_processed.append('fill')
            self.fill = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class layer


class classxx(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, number=None, drill=None, name=None, clearance=None):
        self.width = _cast(None, width)
        self.number = _cast(None, number)
        self.drill = _cast(None, drill)
        self.name = _cast(None, name)
        self.clearance = clearance
    def factory(*args_, **kwargs_):
        if classxx.subclass:
            return classxx.subclass(*args_, **kwargs_)
        else:
            return classxx(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clearance(self): return self.clearance
    def set_clearance(self, clearance): self.clearance = clearance
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_drill(self): return self.drill
    def set_drill(self, drill): self.drill = drill
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='t:', name_='class', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='class')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='class'):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            outfile.write(' width=%s' % (self.gds_format_string(quote_attrib(self.width).encode(ExternalEncoding), input_name='width'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding), input_name='number'), ))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            outfile.write(' drill=%s' % (self.gds_format_string(quote_attrib(self.drill).encode(ExternalEncoding), input_name='drill'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='class', fromsubclass_=False):
        if self.clearance is not None:
            self.clearance.export(outfile, level, namespace_, name_='clearance', )
    def hasContent_(self):
        if (
            self.clearance is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='class'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.width is not None and 'width' not in already_processed:
            already_processed.append('width')
            showIndent(outfile, level)
            outfile.write('width = "%s",\n' % (self.width,))
        if self.number is not None and 'number' not in already_processed:
            already_processed.append('number')
            showIndent(outfile, level)
            outfile.write('number = "%s",\n' % (self.number,))
        if self.drill is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            showIndent(outfile, level)
            outfile.write('drill = "%s",\n' % (self.drill,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.clearance is not None:
            showIndent(outfile, level)
            outfile.write('clearance=model_.clearance(\n')
            self.clearance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.append('width')
            self.width = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.append('number')
            self.number = value
        value = find_attr_value_('drill', node)
        if value is not None and 'drill' not in already_processed:
            already_processed.append('drill')
            self.drill = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clearance':
            obj_ = clearance.factory()
            obj_.build(child_)
            self.set_clearance(obj_)
# end class classxx


class clearance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classxx=None, value=None):
        self.classxx = _cast(None, classxx)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if clearance.subclass:
            return clearance.subclass(*args_, **kwargs_)
        else:
            return clearance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='t:', name_='clearance', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clearance')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='clearance'):
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='clearance', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clearance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.append('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.append('class')
            self.classxx = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clearance


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None, mixedclass_=None, content_=None):
        self.language = _cast(None, language)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='t:', name_='description', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='description'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='description', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.language is not None and 'language' not in already_processed:
            already_processed.append('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.append('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class description


class param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if param.subclass:
            return param.subclass(*args_, **kwargs_)
        else:
            return param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='t:', name_='param', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='param')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='param'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='param', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='param'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class param


class passxx(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, active=None, name=None, refer=None, param=None):
        self.active = _cast(None, active)
        self.name = _cast(None, name)
        self.refer = _cast(None, refer)
        self.param = param
    def factory(*args_, **kwargs_):
        if passxx.subclass:
            return passxx.subclass(*args_, **kwargs_)
        else:
            return passxx(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_refer(self): return self.refer
    def set_refer(self, refer): self.refer = refer
    def export(self, outfile, level, namespace_='t:', name_='pass', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pass')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='pass'):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (self.gds_format_string(quote_attrib(self.active).encode(ExternalEncoding), input_name='active'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.refer is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            outfile.write(' refer=%s' % (self.gds_format_string(quote_attrib(self.refer).encode(ExternalEncoding), input_name='refer'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='pass', fromsubclass_=False):
        if self.param is not None:
            self.param.export(outfile, level, namespace_, name_='param', )
    def hasContent_(self):
        if (
            self.param is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pass'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = "%s",\n' % (self.active,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.refer is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            showIndent(outfile, level)
            outfile.write('refer = "%s",\n' % (self.refer,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.param is not None:
            showIndent(outfile, level)
            outfile.write('param=model_.param(\n')
            self.param.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('refer', node)
        if value is not None and 'refer' not in already_processed:
            already_processed.append('refer')
            self.refer = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.set_param(obj_)
# end class passxx


class approved(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hash=None):
        self.hash = _cast(None, hash)
        pass
    def factory(*args_, **kwargs_):
        if approved.subclass:
            return approved.subclass(*args_, **kwargs_)
        else:
            return approved(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hash(self): return self.hash
    def set_hash(self, hash): self.hash = hash
    def export(self, outfile, level, namespace_='t:', name_='approved', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='approved')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='t:', name_='approved'):
        if self.hash is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            outfile.write(' hash=%s' % (self.gds_format_string(quote_attrib(self.hash).encode(ExternalEncoding), input_name='hash'), ))
    def exportChildren(self, outfile, level, namespace_='t:', name_='approved', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='approved'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hash is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            showIndent(outfile, level)
            outfile.write('hash = "%s",\n' % (self.hash,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hash', node)
        if value is not None and 'hash' not in already_processed:
            already_processed.append('hash')
            self.hash = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class approved


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="eagle",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'eagle'
        rootClass = eagle
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from eagle import *\n\n')
    sys.stdout.write('import eagle as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "approved",
    "attribute",
    "attributes",
    "autorouter",
    "board",
    "bus",
    "busses",
    "circle",
    "classes",
    "classxx",
    "clearance",
    "compatibility",
    "connect",
    "connects",
    "contactref",
    "description",
    "designrules",
    "device",
    "devices",
    "deviceset",
    "devicesets",
    "dimension",
    "drawing",
    "eagle",
    "element",
    "elements",
    "errors",
    "frame",
    "gate",
    "gates",
    "grid",
    "hole",
    "instance",
    "instances",
    "junction",
    "label",
    "layer",
    "layers",
    "libraries",
    "library",
    "net",
    "nets",
    "note",
    "package",
    "packages",
    "pad",
    "param",
    "part",
    "parts",
    "passxx",
    "pin",
    "pinref",
    "plain",
    "polygon",
    "rectangle",
    "schematic",
    "segment",
    "setting",
    "settings",
    "sheet",
    "sheets",
    "signal",
    "signals",
    "smd",
    "symbol",
    "symbols",
    "technologies",
    "technology",
    "text",
    "variant",
    "variantdef",
    "variantdefs",
    "vertex",
    "via",
    "wire"
    ]
